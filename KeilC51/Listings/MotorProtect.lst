C51 COMPILER V9.52.0.0   MOTORPROTECT                                                      12/02/2025 15:24:48 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MOTORPROTECT
OBJECT MODULE PLACED IN .\Output\MotorProtect.obj
COMPILER INVOKED BY: E:\tools\keil4\C51\BIN\C51.EXE ..\User\source\Function\MotorProtect.c LARGE OMF2 WARNINGLEVEL(0) BR
                    -OWSE FLOATFUZZY(4) INCDIR(..\User\include;..\FU68xx_Haidware_Driver\Include) DEBUG PRINT(.\Listings\MotorProtect.lst) TA
                    -BS(2) OBJECT(.\Output\MotorProtect.obj)

line level    source

   1          /* --------------------------- (C) COPYRIGHT 2020 Fortiortech ShenZhen -----------------------------
   2              File Name      : MotorControl.c
   3              Author         : Fortiortech  Appliction Team
   4              Version        : V1.0
   5              Date           : 2020-04-10
   6              Description    : This file contains .C file function used for Motor Control.
   7          ----------------------------------------------------------------------------------------------------
   8                                                 All Rights Reserved
   9          ------------------------------------------------------------------------------------------------- */
  10          #include <MyProject.h>
  11          extern bool OpenFlag;
  12          
  13          /*  -------------------------------------------------------------------------------------------------
  14              Function Name  : FaultProcess
  15              Description    : ??????,??FOC??,???????mcFault
  16              Date           : 2020-04-10
  17              Parameter      : None
  18              ------------------------------------------------------------------------------------------------- */
  19          void FaultProcess(void)
  20          {
  21   1          if(mcFaultSource != FaultNoSource)
  22   1          {
  23   2      //        ClrBit(DRV_CR, DRVEN);  //Driver Disable
  24   2      //        ClrBit(DRV_CR, FOCEN);  //FOC Disable
  25   2              MOE     = 0;
  26   2              _nop_();
  27   2          }
  28   1          else if(OpenFlag == 0)
  29   1          {
  30   2              mcState = mcReady;
  31   2          }
  32   1          else
  33   1          {
  34   2      //        SetBit(DRV_CR, FOCEN);
  35   2              MOE  = 1;
  36   2              mcState = mcRun;
  37   2          }
  38   1      }
  39          
  40          
  41          /*  -------------------------------------------------------------------------------------------------
  42              Function Name  : Fault_OverUnderVoltage
  43              Description    : è¿‡å‹æ¬ å‹ä¿æŠ¤å‡½æ•°ï¼šç¨‹åºæ¯5msåˆ¤æ–­ä¸€æ¬¡ï¼Œæ¯çº¿ç”µå‹å¤§äºè¿‡å‹ä¿æŠ¤å
             -€¼æ—¶ï¼Œè®¡æ•°å™¨åŠ ä¸€ï¼Œè®¡æ•°å™¨å€¼è¶…è¿‡20æ¬¡ï¼Œåˆ¤æ–­ä¸ºè¿‡å‹ä¿æŠ¤ï¼Œå…³é—­è¾“å‡º;åä¹‹ï¼Œè®¡æ•°å™¨æ…¢æ…¢å‡
  44                               åŒç†ï¼Œæ¬ å‹ä¿æŠ¤ã€‚
  45                               ç”µæœºè¿‡æ¬ å‹ä¿æŠ¤çŠ¶æ€ä¸‹ï¼Œæ¯çº¿ç”µå‹æ¢å¤åˆ°æ¬ å‹æ¢å¤å€¼ä»¥ä¸Šï¼Œè¿‡å‹æ
             -¢å¤å€¼ä»¥ä¸‹æ—¶ï¼Œè®¡æ•°å™¨åŠ ä¸€ï¼Œè¶…è¿‡200æ¬¡åï¼Œæ¢å¤ã€‚æ ¹æ®æ¡£ä½ä¿¡æ¯æ¥å†³å®šæ¢å¤åˆ°å“ªä¸ªçŠ¶æ€ã€‚
  46              Date           : 2020-04-10
  47              Parameter      : h_Fault: [è¾“å…¥/å‡º]
  48              ------------------------------------------------------------------------------------------------- */
  49          void Fault_OverUnderVoltage(void)
  50          {
  51   1      //    if (mcFaultDect.UnderVoltageDelayCnt <= 2000) //5s
C51 COMPILER V9.52.0.0   MOTORPROTECT                                                      12/02/2025 15:24:48 PAGE 2   

  52   1      //        {
  53   1      //            mcFaultDect.UnderVoltageDelayCnt++;
  54   1      //        }
  55   1      //    else 
  56   1          if (mcFaultSource == FaultNoSource) //ç¨‹åºæ— å…¶ä»–ä¿æŠ¤ä¸‹
  57   1          {
  58   2              //è¿‡å‹ä¿æŠ¤
  59   2              if (mcFocCtrl.mcDcbusFlt > OVER_PROTECT_VALUE)   //æ¯çº¿ç”µå‹å¤§äºè¿‡å‹ä¿æŠ¤å€¼æ—¶ï¼Œè®¡æ•°ï¼
             -Œè¶…è¿‡20æ¬¡ï¼Œåˆ¤æ–­ä¸ºè¿‡å‹ä¿æŠ¤ï¼Œå…³é—­è¾“å‡º;åä¹‹ï¼Œè®¡æ•°å™¨æ…¢æ…¢å‡
  60   2              {
  61   3                  mcFaultDect.OverVoltDetecCnt++;
  62   3                  
  63   3                  if (mcFaultDect.OverVoltDetecCnt > 10) //æ£€æµ‹50ms
  64   3                  {
  65   4                      mcFaultDect.OverVoltDetecCnt = 0;
  66   4                      mcFaultSource             = FaultOverVoltage;
  67   4      //                mcFaultDect.CurrentFlag = 0;
  68   4                      mcState = mcFault;
  69   4                  }
  70   3              }
  71   2              else if (mcFaultDect.OverVoltDetecCnt > 0)
  72   2              {
  73   3                  mcFaultDect.OverVoltDetecCnt--;
  74   3              }
  75   2              
  76   2              //æ¬ å‹ä¿æŠ¤
  77   2              if (mcFocCtrl.mcDcbusFlt < UNDER_PROTECT_VALUE)
  78   2              {
  79   3                  mcFaultDect.UnderVoltDetecCnt++;
  80   3                  
  81   3                  if (mcFaultDect.UnderVoltDetecCnt > 10) //æ£€æµ‹50ms
  82   3                  {
  83   4                      mcFaultDect.UnderVoltDetecCnt = 0;
  84   4                      mcFaultSource              = FaultUnderVoltage;
  85   4                      mcState = mcFault;
  86   4                  }
  87   3              }
  88   2              else if (mcFaultDect.UnderVoltDetecCnt > 0)
  89   2              {
  90   3                  mcFaultDect.UnderVoltDetecCnt--;
  91   3              }
  92   2          }
  93   1          
  94   1          /*******è¿‡å‹æ¬ å‹ä¿æŠ¤æ¢å¤*********/
  95   1          if ((mcState == mcFault) && ((mcFaultSource == FaultUnderVoltage) || (mcFaultSource == FaultOverVoltag
             -e)))
  96   1          {
  97   2              if ((mcFocCtrl.mcDcbusFlt < OVER_RECOVER_VALUE) && (mcFocCtrl.mcDcbusFlt > UNDER_RECOVER_VALUE))
  98   2              {
  99   3                  mcFaultDect.VoltRecoverCnt++;
 100   3                  
 101   3                  if (mcFaultDect.VoltRecoverCnt > 40) //è¿ç»­æ£€æµ‹200msï¼Œè‹¥æ­£å¸¸åˆ™æ¢å¤
 102   3                  {
 103   4      //                mcState                 = mcReady;
 104   4                      mcFaultSource           = FaultNoSource;
 105   4                      mcFaultDect.VoltRecoverCnt = 0;
 106   4                  }
 107   3              }
 108   2              else
 109   2              {
 110   3                  mcFaultDect.VoltRecoverCnt = 0;
 111   3              }
C51 COMPILER V9.52.0.0   MOTORPROTECT                                                      12/02/2025 15:24:48 PAGE 3   

 112   2          }
 113   1      }
 114          
 115          /*  -------------------------------------------------------------------------------------------------
 116              Function Name  : Fault_Overcurrent
 117              Description    : ç”µæœºè¿è¡Œæˆ–è€…å¯åŠ¨æ—¶ï¼Œå½“ä¸‰ç›¸ä¸­æŸä¸€ç›¸æœ€å¤§å€¼å¤§äºOverCurrentValueï¼Œ
             -åˆ™OverCurCntåŠ 1ã€‚
 118                               è¿ç»­ç´¯åŠ 3æ¬¡ï¼Œåˆ¤æ–­ä¸ºè½¯ä»¶è¿‡æµä¿æŠ¤ã€‚æ‰§è¡Œæ—¶é—´çº¦30.4usã€‚
 119              Date           : 2020-04-10
 120              Parameter      : h_Cur: [è¾“å…¥/å‡º]
 121              ------------------------------------------------------------------------------------------------- */
 122          void Fault_Overcurrent(void)
 123          {
 124   1          if ((mcState == mcRun) || (mcState == mcStart))                       // check over current in rum and
             - open mode
 125   1          {
 126   2              // æ­¤éƒ¨åˆ†æ—¢ç”¨äºè½¯ä»¶è¿‡æµä¿æŠ¤ï¼Œåˆç”¨äºç¼ºç›¸ä¿æŠ¤
 127   2              mcCurVarible.Max_ia = FOC__IAMAX;
 128   2              mcCurVarible.Max_ib = FOC__IBMAX;
 129   2              mcCurVarible.Max_ic = FOC__ICMAX;
 130   2              mcCurVarible.Max_ia = FOC__IAMAX;
 131   2              mcCurVarible.Max_ib = FOC__IBMAX;
 132   2              mcCurVarible.Max_ic = FOC__ICMAX;
 133   2              
 134   2              if ((FOC__IAMAX >= OverSoftCurrentValue)
 135   2                  || (FOC__IBMAX >= OverSoftCurrentValue)
 136   2                  || (FOC__ICMAX >= OverSoftCurrentValue))
 137   2              {
 138   3                  mcCurVarible.OverCurCnt++;
 139   3                  
 140   3                  if (mcCurVarible.OverCurCnt >= 3)
 141   3                  {
 142   4      //                mcState = mcFault;
 143   4      //                mcFaultSource     = FaultSoftOVCurrent;
 144   4                      mcFaultDect.CurrentFlag = 1;
 145   4                      mcCurVarible.Max_ia     = 0;
 146   4                      mcCurVarible.Max_ib     = 0;
 147   4                      mcCurVarible.Max_ic     = 0;
 148   4                      mcCurVarible.OverCurCnt = 0;
 149   4                  }
 150   3              }
 151   2              else if (mcCurVarible.OverCurCnt > 0)
 152   2              {
 153   3                  mcCurVarible.OverCurCnt--;
 154   3              }
 155   2          }
 156   1      }
 157          
 158          /*  -------------------------------------------------------------------------------------------------
 159              Function Name  : Fault_OverCurrentRecover
 160              Description    : è½¯ç¡¬ä»¶è¿‡æµä¿æŠ¤æ¢å¤
 161              Date           : 2020-04-10
 162              Parameter      : h_Fault: [è¾“å…¥/å‡º]
 163              ------------------------------------------------------------------------------------------------- */
 164          void Fault_OverCurrentRecover(void)
 165          {
 166   1          if ((mcState == mcFault) && ((mcFaultSource == FaultSoftOVCurrent)
 167   1                  || (mcFaultSource == FaultHardOVCurrent))) //&& (mcProtectTime.CurrentPretectTimes < 5))
 168   1          {
 169   2              mcFaultDect.CurrentRecoverCnt++;
 170   2              
 171   2              if (mcFaultDect.CurrentRecoverCnt >= OverCurrentRecoverTime) //200*5=1s
C51 COMPILER V9.52.0.0   MOTORPROTECT                                                      12/02/2025 15:24:48 PAGE 4   

 172   2              {
 173   3                  mcFaultDect.CurrentRecoverCnt = 0;
 174   3                  mcProtectTime.CurrentPretectTimes++;
 175   3      //            mcState       = mcReady;
 176   3                  mcFaultSource = FaultNoSource;
 177   3                  mcFaultDect.CurrentFlag = 0;
 178   3              }
 179   2          }
 180   1      }
 181          
 182          
 183          /*  -------------------------------------------------------------------------------------------------
 184              Function Name  : Fault_Stall
 185              Description    : å µè½¬ä¿æŠ¤å‡½æ•°ï¼Œæœ‰ä¸‰ç§ä¿æŠ¤æ–¹å¼ï¼Œ
 186                             ç¬¬ä¸€ç§ï¼Œ
 187                             ç¬¬äºŒç§ï¼Œç”µæœºè¿è¡ŒçŠ¶æ€ä¸‹ï¼Œå»¶è¿Ÿ4såˆ¤æ–­ï¼Œä¼°ç®—é€Ÿåº¦ç»å¯¹å€¼è¶…è¿‡å µè½¬é
             -€Ÿåº¦è¿ç»­5æ¬¡ï¼›
 188                             ç¬¬ä¸‰ç§ï¼Œç”µæœºè¿è¡ŒçŠ¶æ€ä¸‹ï¼Œå½“U,Vä¸¤ç›¸ç”µæµç»å¯¹å€¼å¤§äºå µè½¬ç”µæµä¿æŠ¤
             -å€¼è¿ç»­6æ¬¡ï¼›
 189                             å½“ä»¥ä¸Šä¸‰ç§çš„ä»»ä½•ä¸€ç§ä¿æŠ¤è§¦å‘æ—¶ï¼Œç”µæœºåœæœºï¼Œç¨‹åºåˆ¤æ–­ä¸ºå µè½¬ä¿
             -æŠ¤ï¼›
 190                             å½“å µè½¬ä¿æŠ¤çŠ¶æ€ä¸‹ï¼ŒUç›¸é‡‡é›†å€¼ä½äºå µè½¬æ¢å¤å€¼æ—¶ï¼Œè‹¥å µè½¬æ¬¡æ•°å°äº
             -æˆ–ç­‰äºå µè½¬é‡å¯æ¬¡æ•°8æ¬¡ï¼Œ
 191                             ç¨‹åºå»¶è¿ŸmcStallRecoveré‡æ–°å¯åŠ¨ï¼Œè¿›è¡Œæ ¡å‡†çŠ¶æ€ã€‚
 192              Date           : 2020-04-10
 193              Parameter      : h_Fault: [è¾“å…¥/å‡º]
 194              ------------------------------------------------------------------------------------------------- */
 195          int16 IQ;
 196          void Fault_Stall(void)
 197          {
 198   1          if (mcState == mcRun)
 199   1          {
 200   2              if (mcFaultDect.StallDelayCnt <= 2000) //5s
 201   2              {
 202   3                  mcFaultDect.StallDelayCnt++;
 203   3              }
 204   2              else
 205   2              {
 206   3                  IQ = FOC__IQ;
 207   3                  if((mcFocCtrl.SpeedFlt < Motor_Stall_Min_Speed) && ((IQ > I_Value(0.46)) || (IQ < I_Value(-0.4
             -6))))
 208   3      
 209   3      //          if((mcFocCtrl.SpeedFlt < Motor_Stall_Min_Speed) && ((IQ > I_Value(0.48)) || (IQ < I_Value(-0.4
             -8))))
 210   3                  {
 211   4                      mcFaultDect.StallDectSpeed++;
 212   4                    
 213   4                      if (mcFaultDect.StallDectSpeed >= 100)
 214   4      
 215   4      //             if (mcFaultDect.StallDectSpeed >= 100)
 216   4                      {
 217   5                          mcFaultDect.StallDectSpeed = 0;
 218   5                          mcFaultSource           = FaultStall;
 219   5                          mcProtectTime.StallTimes++;
 220   5                          mcState = mcFault;
 221   5                          mcProtectTime.StallFlag = 1;
 222   5                      }
 223   4                  }
 224   3                  //method 2ï¼Œåˆ¤æ–­é€Ÿåº¦ä½äºå µè½¬æœ€å°å€¼æˆ–è€…è¶…è¿‡å µè½¬æœ€å¤§å€¼
 225   3                  else if (mcFocCtrl.SpeedFlt > Motor_Stall_Max_Speed)
 226   3                  {
 227   4                      mcFaultDect.StallDectSpeed++;
C51 COMPILER V9.52.0.0   MOTORPROTECT                                                      12/02/2025 15:24:48 PAGE 5   

 228   4                      
 229   4                      if (mcFaultDect.StallDectSpeed >= 10)
 230   4                      {
 231   5                          mcFaultDect.StallDectSpeed = 0;
 232   5                          mcFaultSource           = FaultStall;
 233   5                          mcProtectTime.StallTimes++;
 234   5                          mcState = mcFault;
 235   5                          mcProtectTime.StallFlag = 2;
 236   5                      }
 237   4                  }
 238   3                  else
 239   3                  {
 240   4                      if (mcFaultDect.StallDectSpeed > 0)
 241   4                      {
 242   5                          mcFaultDect.StallDectSpeed--;
 243   5                      }
 244   4                  }
 245   3                
 246   3              }
 247   2          }
 248   1          
 249   1          #if (!StartONOFF_Enable)
 250   1          {
 251   2              /*******å µè½¬ä¿æŠ¤æ¢å¤*********/
 252   2              if ((mcFaultSource == FaultStall) && (mcState == mcFault)) //&& (mcProtectTime.StallTimes <= Stall
             -ProtectRestartTimes))
 253   2              {
 254   3                  mcFaultDect.StallReCount++;
 255   3                  
 256   3                  if (mcFaultDect.StallReCount >= StallRecoverTime)
 257   3                  {
 258   4                      mcFaultDect.StallReCount = 0;
 259   4                      mcFaultSource         = FaultNoSource;
 260   4      //                mcState               = mcReady;
 261   4                  }
 262   3              }
 263   2              else
 264   2              {
 265   3                  mcFaultDect.StallReCount = 0;
 266   3              }
 267   2          }
 268   1          #endif
 269   1      }
 270          
 271          /*  -------------------------------------------------------------------------------------------------
 272              Function Name  : Fault_phaseloss
 273              Description    : ç¼ºç›¸ä¿æŠ¤å‡½æ•°ï¼Œå½“ç”µæœºè¿è¡ŒçŠ¶æ€ä¸‹ï¼Œ10mså–ä¸‰ç›¸ç”µæµçš„æœ€å¤§å€¼ï¼Œ
 274                             1.5såˆ¤æ–­å„ç›¸ç”µæµæœ€å¤§å€¼ï¼Œè‹¥å­˜åœ¨ä¸¤ç›¸ç”µæµå€¼å¤§äºä¸€å®šå€¼ï¼Œè€Œç¬¬ä¸‰ç›
             -¸ç”µæµå€¼å´éå¸¸å°ï¼Œåˆ™åˆ¤æ–­ä¸ºç¼ºç›¸ä¿æŠ¤ï¼Œç”µæœºåœæœºï¼›
 275              Date           : 2020-04-10
 276              Parameter      : h_Fault: [è¾“å…¥/å‡º]
 277              ------------------------------------------------------------------------------------------------- */
 278          void Fault_phaseloss(void)
 279          {
 280   1          if (mcState == mcRun)
 281   1          {
 282   2              mcFaultDect.Lphasecnt++;
 283   2              
 284   2              if (mcFaultDect.Lphasecnt > 100) //100*5=500ms
 285   2              {
 286   3                  mcFaultDect.Lphasecnt = 0;
 287   3                  
C51 COMPILER V9.52.0.0   MOTORPROTECT                                                      12/02/2025 15:24:48 PAGE 6   

 288   3                  if (((mcCurVarible.Max_ia > (mcCurVarible.Max_ib * 2)) || (mcCurVarible.Max_ia > (mcCurVarible
             -.Max_ic * 2)))
 289   3                      && (mcCurVarible.Max_ia > PhaseLossCurrentValue))
 290   3                  {
 291   4                      mcFaultDect.AOpencnt++;
 292   4                  }
 293   3                  else
 294   3                  {
 295   4                      if (mcFaultDect.AOpencnt > 0)
 296   4                      {
 297   5                          mcFaultDect.AOpencnt --;
 298   5                      }
 299   4                  }
 300   3                  
 301   3                  if (((mcCurVarible.Max_ib > (mcCurVarible.Max_ia * 2)) || (mcCurVarible.Max_ib > (mcCurVarible
             -.Max_ic * 2)))
 302   3                      && (mcCurVarible.Max_ib > PhaseLossCurrentValue))
 303   3                  {
 304   4                      mcFaultDect.BOpencnt++;
 305   4                  }
 306   3                  else
 307   3                  {
 308   4                      if (mcFaultDect.BOpencnt > 0)
 309   4                      {
 310   5                          mcFaultDect.BOpencnt --;
 311   5                      }
 312   4                  }
 313   3                  
 314   3                  if (((mcCurVarible.Max_ic > (mcCurVarible.Max_ia * 2)) || (mcCurVarible.Max_ic > (mcCurVarible
             -.Max_ib * 2)))
 315   3                      && (mcCurVarible.Max_ic > PhaseLossCurrentValue))
 316   3                  {
 317   4                      mcFaultDect.COpencnt++;
 318   4                  }
 319   3                  else
 320   3                  {
 321   4                      if (mcFaultDect.COpencnt > 0)
 322   4                      {
 323   5                          mcFaultDect.COpencnt --;
 324   5                      }
 325   4                  }
 326   3                  
 327   3                  mcCurVarible.Max_ia = 0;
 328   3                  mcCurVarible.Max_ib = 0;
 329   3                  mcCurVarible.Max_ic = 0;
 330   3                  SetBit(FOC_CR2, ICLR);
 331   3                  
 332   3                  if ((mcFaultDect.AOpencnt > 1) || (mcFaultDect.BOpencnt > 1) || (mcFaultDect.COpencnt > 1))
 333   3                  {
 334   4                      mcProtectTime.LossPHTimes++;
 335   4                      mcFaultSource = FaultLossPhase;
 336   4                      mcState = mcFault;
 337   4                  }
 338   3              }
 339   2          }
 340   1          
 341   1          #if (!StartONOFF_Enable)
 342   1          {
 343   2              /*******ç¼ºç›¸ä¿æŠ¤æ¢å¤*********/
 344   2              if ((mcFaultSource == FaultLossPhase) && (mcState == mcFault)) //&& (mcProtectTime.LossPHTimes <= 
             -PhaseLossRestartTimes)) //å¯é‡å¯5æ¬¡
 345   2              {
C51 COMPILER V9.52.0.0   MOTORPROTECT                                                      12/02/2025 15:24:48 PAGE 7   

 346   3                  mcFaultDect.mcLossPHRecCount++;
 347   3                  
 348   3                  if (mcFaultDect.mcLossPHRecCount >= PhaseLossRecoverTime)
 349   3                  {
 350   4                      mcFaultDect.AOpencnt = 0;
 351   4                      mcFaultDect.BOpencnt = 0;
 352   4                      mcFaultDect.COpencnt = 0;
 353   4      //                mcState           = mcReady;
 354   4                      mcFaultSource     = FaultNoSource;
 355   4                  }
 356   3              }
 357   2              else
 358   2              {
 359   3                  mcFaultDect.mcLossPHRecCount = 0;
 360   3              }
 361   2          }
 362   1          #endif
 363   1      }
 364          
 365          /*  -------------------------------------------------------------------------------------------------
 366              Function Name  : Fault_Detection
 367              Description    : ä¿æŠ¤å‡½æ•°ï¼Œå› ä¿æŠ¤çš„æ—¶é—´å“åº”ä¸ä¼šå¾ˆé«˜ï¼Œé‡‡ç”¨åˆ†æ®µå¤„ç†ï¼Œæ¯5ä¸ªå®š
             -æ—¶å™¨ä¸­æ–­æ‰§è¡Œä¸€æ¬¡å¯¹åº”çš„ä¿æŠ¤
 368                               å¸¸è§ä¿æŠ¤æœ‰è¿‡æ¬ å‹ã€è¿‡æ¸©ã€å µè½¬ã€å¯åŠ¨ã€ç¼ºç›¸ç­‰ä¿æŠ¤ï¼Œè°ƒè¯•æ—¶ï¼Œå
             -¯æ ¹æ®éœ€æ±‚ï¼Œä¸€ä¸ªä¸ªçš„è°ƒè¯•åŠ å…¥ã€‚
 369              Date           : 2020-04-10
 370              Parameter      : None
 371              ------------------------------------------------------------------------------------------------- */
 372          void Fault_Detection(void)
 373          {
 374   1        
 375   1              if (OverSoftCurrentEnable) //è¿‡æµä¿æŠ¤æ¢å¤ä½¿èƒ½
 376   1              {
 377   2      //            Fault_OverCurrentRecover();
 378   2                  Fault_Overcurrent();
 379   2              }
 380   1          
 381   1         
 382   1              if (VoltageProtectEnable == 1) //è¿‡å‹ä¿æŠ¤ä½¿èƒ½
 383   1              {
 384   2                  Fault_OverUnderVoltage();
 385   2              }
 386   1          
 387   1       
 388   1        
 389   1              if (StallProtectEnable == 1) //å µè½¬ä¿æŠ¤ä½¿èƒ½
 390   1              {
 391   2                  Fault_Stall();
 392   2              }
 393   1        
 394   1              if (PhaseLossProtectEnable == 1) //ç¼ºç›¸ä¿æŠ¤ä½¿èƒ½
 395   1              {
 396   2                  Fault_phaseloss();
 397   2              }
 398   1          
 399   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1224    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2    ----
C51 COMPILER V9.52.0.0   MOTORPROTECT                                                      12/02/2025 15:24:48 PAGE 8   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       12/02/2025 15:24:47 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE ADDFUNCTION
OBJECT MODULE PLACED IN .\Output\AddFunction.obj
COMPILER INVOKED BY: E:\tools\keil4\C51\BIN\C51.EXE ..\User\source\Application\AddFunction.c LARGE OMF2 WARNINGLEVEL(0) 
                    -BROWSE FLOATFUZZY(4) INCDIR(..\User\include;..\FU68xx_Haidware_Driver\Include) DEBUG PRINT(.\Listings\AddFunction.lst) T
                    -ABS(2) OBJECT(.\Output\AddFunction.obj)

line level    source

   1          /*  -------------------------- (C) COPYRIGHT 2020 Fortiortech ShenZhen ---------------------------*/
   2          /*  File Name      : AddFunction.c
   3          /*  Author         : Fortiortech  Appliction Team
   4          /*  Version        : V1.0
   5          /*  Date           : 2020-08-21
   6          /*  Description    : This file contains XX-XX-XX function used for Motor Control.
   7          /*  ----------------------------------------------------------------------------------------------*/
   8          /*                                     All Rights Reserved
   9          /*  ----------------------------------------------------------------------------------------------*/
  10          
  11          #include "MyProject.h"
  12          #include "math.h"
  13          
  14          uint8 data isCtrlPowerOn = false;
  15          
  16          
  17          FaultStateType             mcFaultSource;
  18          
  19          FaultVarible       idata   mcFaultDect;
  20          CurrentVarible     mcCurVarible;
  21          ProtectVarible     xdata   mcProtectTime;
  22          PWMINPUTCAL    xdata mcPwmInput;
  23          
  24          MCRAMP             idata   mcSpeedRamp;
  25          MCRAMP             idata   mcPluseramp;
  26          MCRAMP             idata   mcSpeedRampLim;
  27          
  28          FOCCTRL            xdata   mcFocCtrl;
  29          UQ_Posi            xdata   UqPo;
  30          
  31          SPlanTypeDef   xdata mcSP;
  32          
  33          _PID  pid_Pose;               //
  34          
  35          extern float MinAngleLim;
  36          extern float MaxAngleLim;
  37          
  38          
  39          /*  -------------------------------------------------------------------------------------------------
  40              Function Name  : Abs_F32
  41              Description    : ÂØπÂèòÈáèÂèñ32‰ΩçÁöÑÁªùÂØπÂÄº
  42              Date           : 2020-04-10
  43              Parameter      : value: [ËæìÂÖ•/Âá∫]
  44              ------------------------------------------------------------------------------------------------- */
  45          uint32 Abs_F32(int32 value)
  46          {
  47   1          if (value < 0)
  48   1          {
  49   2              return (-value);
  50   2          }
  51   1          else
  52   1          {
  53   2              return (value);
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       12/02/2025 15:24:47 PAGE 2   

  54   2          }
  55   1      }
  56          
  57          
  58          /*  -------------------------------------------------------------------------------------------------
  59              Function Name  : HW_One_PI
  60              Description    : PIÊéßÂà∂
  61              Date           : 2020-04-10
  62              Parameter      : Xn1: [ËæìÂÖ•/Âá∫]
  63              ------------------------------------------------------------------------------------------------- */
  64          int16 HW_PI_0(int16 Xn1)
  65          {
  66   1          PI0_EK = Xn1;          //Â°´ÂÖ•EK
  67   1          SetBit(PI_CR, PI0STA); // Start PI
  68   1          _nop_();
  69   1          _nop_();
  70   1          _nop_();
  71   1          _nop_();
  72   1          return PI0_UKH;
  73   1      }
  74          
  75          int16 HW_PI_1(int16 Xn1)
  76          {
  77   1          PI1_EK = Xn1;          //Â°´ÂÖ•EK
  78   1          SetBit(PI_CR, PI1STA); // Start PI
  79   1          _nop_();
  80   1          _nop_();
  81   1          _nop_();
  82   1          _nop_();
  83   1          return PI1_UKH;
  84   1      }
  85          
  86          int16 HW_PI_2(int16 Xn1)
  87          {
  88   1          PI2_EK = Xn1;          //Â°´ÂÖ•EK
  89   1          SetBit(PI_CR, PI2STA); // Start PI
  90   1          _nop_();
  91   1          _nop_();
  92   1          _nop_();
  93   1          _nop_();
  94   1          return PI2_UKH;
  95   1      }
  96          int16 HW_PI_3(int16 Xn1)
  97          {
  98   1          PI3_EK = Xn1;          //Â°´ÂÖ•EK
  99   1          SetBit(PI_CR, PI3STA); // Start PI
 100   1          _nop_();
 101   1          _nop_();
 102   1          _nop_();
 103   1          _nop_();
 104   1          return PI3_UKH;
 105   1      }
 106          
 107          
 108          float PID_pose(_PID * PID, float err)
 109          {
 110   1          //ËØØÂ∑Æ
 111   1          PID->err = err;
 112   1          //    if (PID->err > 4000) PID->err = 4000;
 113   1          //    if (PID->err < -4000) PID->err = -4000;
 114   1          //    if (PID->err < 30 && PID->err > -30)
 115   1          //    {
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       12/02/2025 15:24:47 PAGE 3   

 116   1          //        PID->err  = 0;
 117   1          //        PID->integral = 0;
 118   1          //    }
 119   1          //    if (PID->err < 200){
 120   1          //ËØØÂ∑ÆÁßØÂàÜ
 121   1          PID->integral += PID->err;
 122   1          //  }
 123   1          // ÁßØÂàÜÈôêÂπÖ
 124   1          PID->integral = (PID->integral > I_Value(0.05)) ?  I_Value(0.05) : PID->integral;
 125   1          PID->integral = (PID->integral < -I_Value(0.05)) ? -I_Value(0.05) : PID->integral;
 126   1          PID->voltage    = PID->Kp * PID->err
 127   1              + PID->Ki * PID->integral;
 128   1          //                    + PID->Kd * (PID->err - PID->err_last);
 129   1          PID->voltage = (PID->voltage > I_Value(0.6)) ?  I_Value(0.6) : PID->voltage;
 130   1          PID->voltage = (PID->voltage < -I_Value(0.6)) ? -I_Value(0.6) : PID->voltage;
 131   1          //‰∏ä‰∏ÄÊ¨°ÁöÑËØØÂ∑Æ
 132   1          PID->err_last = PID->err;
 133   1          return PID->voltage ;
 134   1      }
 135          //Áî®‰∫éÂàùÂßãÂåñPIDÂÄº
 136          void PID_init(_PID * PID, float Kp, float Ki, float Kd)
 137          {
 138   1          PID->SetVal = 45;
 139   1          PID->ActualVal = 0;
 140   1          PID->err = 0;
 141   1          PID->err_last = 0;
 142   1          PID->integral = 0;
 143   1          PID->Kp = Kp;
 144   1          PID->Ki = Ki;
 145   1          PID->Kd = Kd;
 146   1      }
 147          
 148          ///
 149          /*  -------------------------------------------------------------------------------------------------
 150              Function Name  : Speed_response
 151              Description    : ÈÄüÂ∫¶ÂìçÂ∫îÂáΩÊï∞ÔºåÂèØÊ†πÊçÆÈúÄÊ±ÇÂä†ÂÖ•ÊéßÂà∂ÁéØÔºåÂ¶ÇÊÅíËΩ¨Áü©ÊéßÂà∂„ÄÅÊÅíËΩ¨ÈÄüÊ
             -éßÂà∂„ÄÅÊÅíÂäüÁéáÊéßÂà∂
 152              Date           : 2020-04-10
 153              Parameter      : None
 154              ------------------------------------------------------------------------------------------------- */
 155          int32 speedRef;
 156          
 157          int32 speedErr;
 158          uint8 pos_loopCnt = 0;
 159          extern float spd;
 160          int32 PosErr;
 161          
 162          extern uint8 singal;
 163          extern uint8 PosErrSET;
 164          int16 t1 = 0;
 165          
 166          
 167          void Speed_response(void)
 168          {
 169   1          //    int32 errPre;
 170   1          int32 data IqSum;
 171   1          
 172   1          if ((mcState == mcRun))
 173   1          {
 174   2              switch (mcFocCtrl.CtrlMode)
 175   2              {
 176   3                  case 0:
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       12/02/2025 15:24:47 PAGE 4   

 177   3                  {
 178   4                      mcFocCtrl.CtrlMode  = 1;
 179   4                      FOC_DQKP            = DQKP;
 180   4                      FOC_DQKI            = DQKI;
 181   4                  }
 182   3                  break;
 183   3                  
 184   3                  case 1:
 185   3                  {              
 186   4                      if (pos_loopCnt < 2)
 187   4                      {
 188   5                          pos_loopCnt ++;
 189   5                      }
 190   4                      else
 191   4                      {      
 192   5                        PosErr =  mcSP.PulsesNum - mcQEP.CntrSumReal;        
 193   5                        if (PosErr > 30000)
 194   5                        {
 195   6                            PosErr =  30000;
 196   6                        }
 197   5                        if (PosErr < -30000)
 198   5                        {
 199   6                            PosErr = -30000;
 200   6                        }        
 201   5                        speedRef = (PosErr);//(PosErr<<2)+(PosErr>>1);
 202   5                        pos_loopCnt = 0;
 203   5                      }
 204   4                      mcFocCtrl.PosiErr = PosErr;
 205   4                      mc_ramp(&mcSpeedRampLim);        //10
 206   4                      LPF_MDU(mcSpeedRampLim.ActualValue, 5, mcSpeedRampLim.ActualValueFlt, mcSpeedRampLim.Actua
             -lValueFlt_LSB);
 207   4                      
 208   4                      if (speedRef > mcSpeedRampLim.ActualValueFlt)
 209   4                      {
 210   5                          speedRef =  mcSpeedRampLim.ActualValueFlt ;
 211   5                      }
 212   4                      
 213   4                      if (speedRef < -mcSpeedRampLim.ActualValueFlt)
 214   4                      {
 215   5                          speedRef = - mcSpeedRampLim.ActualValueFlt ;
 216   5                      }
 217   4                      #if (Speed_Method == T_Method)
                              {
                                  speedErr = (int32)speedRef - mcFocCtrl.SpeedFlt;
                              }
                              #elif (Speed_Method == M_Method)
 222   4                      {
 223   5                          speedErr = (int32)speedRef - mcQEP.SpeedMFlt;
 224   5                      }
 225   4                      #endif
 226   4                      if (speedErr >  30000)
 227   4                      {
 228   5                          speedErr =  30000;
 229   5                      }
 230   4                      
 231   4                      if (speedErr < -30000)
 232   4                      {
 233   5                          speedErr = -30000;
 234   5                      }
 235   4                      if((speedErr >= -70)&&(speedErr <= 70))
 236   4                      {
 237   5                        mcQEP.timecnt++;
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       12/02/2025 15:24:47 PAGE 5   

 238   5                        if(mcQEP.timecnt >= 3500)
 239   5                        {
 240   6                          mcQEP.timecnt = 0;
 241   6                          speedErr = 0;
 242   6                        }
 243   5                      }
 244   4                      else
 245   4                      {
 246   5                        if(mcQEP.timecnt > 0)
 247   5                        {
 248   6                          mcQEP.timecnt--;
 249   6                        }
 250   5                        
 251   5                      }
 252   4                      mcFocCtrl.mcIqref =  HW_PI_2(speedErr);
 253   4                      if(mcFocCtrl.ThetaIQ_SOURCE == 0)
 254   4                      {
 255   5                        FOC_IQREF = -mcFocCtrl.mcIqref;
 256   5                      }
 257   4                      else
 258   4                      {
 259   5                        
 260   5                      }
 261   4                  }
 262   3                  break;
 263   3              }
 264   2          }
 265   1          else
 266   1          {
 267   2              //        if (Uart.Go_State == 2) //ÈîôËØØ Ê≤°ÊúâÊâßË°å
 268   2              //        {
 269   2              //            if (Uart.Go_Time > 3000) //3s Ê≤°ÊúâÊâßË°å
 270   2              //            {
 271   2              //                Uart.Go_State = 0;
 272   2              //                Uart.EnableTimeCnt  = 0 ;//Á¶ÅÊ≠¢ËÆ°Êó∂Âô®
 273   2              //                Uart.Go_Time = 0;
 274   2              //                Send_Fail();//ÊâßË°åÂ§±Ë¥•
 275   2              //            }
 276   2              //        }
 277   2          }
 278   1      }
 279          
 280          void PWMInputCapture(void)
 281          {
 282   1          uint16 MotorSpeedVSP;
 283   1          
 284   1          if (mcPwmInput.PwmUpdateFlag == 1) // ÊúâÊñ∞ÁöÑdutyÊõ¥Êñ∞
 285   1          {
 286   2              if ((Abs_F32(mcPwmInput.TimeDR - mcPwmInput.PwmCompareOld) < 0xFF) // ËØØÂ∑ÆÂú®1‰∏™Byte‰πãÈó¥ÂÜçÂ§
             -ÑÁêÜ
 287   2                  && (Abs_F32(mcPwmInput.PwmArrOld - mcPwmInput.TimeARR) < 0xFF))      // ËØØÂ∑ÆÂú®1‰∏™Byte‰πãÈó
             -¥ÂÜçÂ§ÑÁêÜ
 288   2              {
 289   3                  mcPwmInput.PwmCompare = (mcPwmInput.TimeDR >> 1);// ÂØπÂÖ∂‰πò‰ª•32768
 290   3                  mcPwmInput.PwmArr     = mcPwmInput.TimeARR;
 291   3                  mcPwmInput.PwmDuty = _Q15((float)mcPwmInput.TimeDR/mcPwmInput.TimeARR);
 292   3      //            DivQ_L_MDU(mcPwmInput.PwmCompare, 0x0000, mcPwmInput.PwmArr, mcPwmInput.PwmDuty);
 293   3      //            ClrBit(TIM3_CR1, T3IPE);          //ËæìÂÖ•Timer PWMÂë®ÊúüÊ£ÄÊµã‰∏≠Êñ≠‰ΩøËÉΩ 0-->Disable  1--
             ->Enable
 294   3      //            ClrBit(TIM3_CR1, T3IFE);          //ËÆ°Êï∞Âô®‰∏äÊ∫¢‰∏≠Êñ≠‰ΩøËÉΩ 0-->Disable  1-->Enable
 295   3              }
 296   2              
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       12/02/2025 15:24:47 PAGE 6   

 297   2              mcPwmInput.PwmUpdateFlag = 0;
 298   2              mcPwmInput.PwmCompareOld = mcPwmInput.TimeDR;//Â∞ÜÊ≠§Ê¨°ÊØîËæÉÂÄºËµãÂÄºÁªô‰∏äÊ¨°ÊØîËæÉÂÄº
 299   2              mcPwmInput.PwmArrOld     = mcPwmInput.TimeARR;//Â∞ÜÊ≠§Ê¨°Âë®ÊúüÂÄºËµãÂÄºÁªô‰∏äÊ¨°Âë®ÊúüÂÄº
 300   2          }
 301   1      }
 302          
 303          void SpeedPlanMs(void)
 304          {
 305   1          //    float PulsesErr;
 306   1          //    float temp;
 307   1          //
 308   1          //    PulsesErr = mcSP.TargetPulsesNum - mcSP.PulsesNum;
 309   1          //
 310   1          //    if (PulsesErr >= mcSP.ACCPulsesNum)
 311   1          //    {
 312   1          //        if (mcSP.Speed < (mcSP.TargetSpeed-mcSP.Acc))
 313   1          //        {
 314   1          //            mcSP.Speed += mcSP.Acc;
 315   1          //            mcSP.AccReal = mcSP.Acc;
 316   1          //        }
 317   1          //    }
 318   1          //    else  if (PulsesErr <= -mcSP.ACCPulsesNum)
 319   1          //    {
 320   1          //        if (mcSP.Speed > (-mcSP.TargetSpeed+mcSP.Acc))
 321   1          //        {
 322   1          //            mcSP.Speed  -= mcSP.Acc;
 323   1          //            mcSP.AccReal = -mcSP.Acc;
 324   1          //        }
 325   1          //    }
 326   1          //    else if (PulsesErr < mcSP.ACCPulsesNum && PulsesErr>1)
 327   1          //    {
 328   1          //        if (mcSP.Speed > mcSP.Acc)
 329   1          //        {
 330   1          //            mcSP.Speed  -= mcSP.Acc;
 331   1          //            mcSP.AccReal = -mcSP.Acc;
 332   1          //        }
 333   1          //    }
 334   1          //    else if(PulsesErr >= -mcSP.ACCPulsesNum && PulsesErr < -1)
 335   1          //    {
 336   1          //        if (mcSP.Speed < (-mcSP.Acc))
 337   1          //        {
 338   1          //            mcSP.Speed += mcSP.Acc;
 339   1          //            mcSP.AccReal = mcSP.Acc;
 340   1          //        }
 341   1          //        else
 342   1          //        {
 343   1          //            mcSP.AccReal = 0;
 344   1          //        }
 345   1          //    }
 346   1          //    else
 347   1          //    {
 348   1          //        mcSP.AccReal = 0;
 349   1          //        mcSP.Speed = 0;
 350   1          //    }
 351   1          //
 352   1          //    mcSP.PulsesNum = mcSP.PulsesNum + mcSP.Speed;
 353   1      }
 354          
 355          void mc_ramp(MCRAMP * hSpeedramp)
 356          {
 357   1          if (--hSpeedramp->DelayCount < 0)
 358   1          {
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       12/02/2025 15:24:47 PAGE 7   

 359   2              hSpeedramp->DelayCount = hSpeedramp->DelayPeriod;
 360   2              
 361   2              if (hSpeedramp->ActualValue < hSpeedramp->TargetValue)
 362   2              {
 363   3                  if (hSpeedramp->ActualValue + hSpeedramp->IncValue < hSpeedramp->TargetValue)
 364   3                  {
 365   4                      hSpeedramp->ActualValue += hSpeedramp->IncValue;
 366   4                  }
 367   3                  else
 368   3                  {
 369   4                      hSpeedramp->ActualValue = hSpeedramp->TargetValue;
 370   4                  }
 371   3              }
 372   2              else
 373   2              {
 374   3                  if (hSpeedramp->ActualValue - hSpeedramp->DecValue > hSpeedramp->TargetValue)
 375   3                  {
 376   4                      hSpeedramp->ActualValue -= hSpeedramp->DecValue;
 377   4                  }
 378   3                  else
 379   3                  {
 380   4                      hSpeedramp->ActualValue = hSpeedramp->TargetValue;
 381   4                  }
 382   3              }
 383   2          }
 384   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1902    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    198      27
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       4
   IDATA SIZE       =     98    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

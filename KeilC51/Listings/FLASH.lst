C51 COMPILER V9.52.0.0   FLASH                                                             12/02/2025 15:24:49 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE FLASH
OBJECT MODULE PLACED IN .\Output\FLASH.obj
COMPILER INVOKED BY: E:\tools\keil4\C51\BIN\C51.EXE ..\User\source\Hardware\FLASH.c LARGE OMF2 WARNINGLEVEL(0) BROWSE FL
                    -OATFUZZY(4) INCDIR(..\User\include;..\FU68xx_Haidware_Driver\Include) DEBUG PRINT(.\Listings\FLASH.lst) TABS(2) OBJECT(.
                    -\Output\FLASH.obj)

line level    source

   1          /*  --------------------------- (C) COPYRIGHT 2020 Fortiortech ShenZhen -----------------------------
   2              File Name      : FLASH.c
   3              Author         : Fortiortech  Appliction Team
   4              Version        : V1.0
   5              Date           : 2020-04-11
   6              Description    : This file contains .C file function used for Motor Control.
   7              ----------------------------------------------------------------------------------------------------
   8                                                 All Rights Reserved
   9              ------------------------------------------------------------------------------------------------- */
  10          /******************************************************************************///Including Header Files
  11          #include "Myproject.h"
  12          /******************************************************************************///Define Macro
  13          
  14          
  15          ROM_TypeDef xdata  Rom;
  16          
  17          uint8 Flash_GetAddress(void);
  18          uint8 Flash_ErasePageRom(uint8 xdata *FlashAddress);
  19          //void Flash_KeyWriteValue(uint8 *value, uint16 FlashAddress , uint8 length);
  20          
  21          
  22          uint8 Flash_Sector_Erase(uint8 xdata *FlashAddress)
  23          {
  24   1          bool TempEA;
  25   1      
  26   1          TempEA = EA;
  27   1          EA = 0;                            //Flash自擦除前先关总中断
  28   1      
  29   1          if(FlashAddress < 0x3f80)          // 不擦除最后一个扇区,0X3F80~0X3FFF
  30   1          {
  31   2              FLA_CR = 0x03;                 //使能自擦除
  32   2              FLA_KEY = 0x5a;
  33   2              FLA_KEY = 0x1f;                //flash预编程解锁
  34   2              _nop_();
  35   2              *FlashAddress = 0xff;          //写任意数据
  36   2              FLA_CR = 0x08;                 //开始预编程，完成后Flash再次上锁
  37   2          }
  38   1      
  39   1          EA = TempEA;                       //Flash自擦除后总中断恢复 
  40   1      
  41   1          if(ReadBit(FLA_CR, FLAERR))
  42   1          {
  43   2              return 1;
  44   2          }
  45   1          else
  46   1          {
  47   2              return 0;
  48   2          }
  49   1      }
  50          
  51          /*-------------------------------------------------------------------------------------------------
  52              Function Name : uint8 Flash_Sector_Write(uint8 xdata *FlashAddress, uint8 FlashData)
  53              Description   : Flash自烧写: 对扇区预编程和自擦除后，可以对扇区内的地址进行F
C51 COMPILER V9.52.0.0   FLASH                                                             12/02/2025 15:24:49 PAGE 2   

             -lash烧写，
  54                              一次烧写一个byte,一定要在解锁后才给DPTR赋值
  55              Input         : FlashAddress--Flash烧写地址
  56                              FlashData--Flash烧写数据
  57              Output        : 0--Flash自烧写成功，1--Flash自烧写失败
  58          -------------------------------------------------------------------------------------------------*/
  59          uint8 Flash_Sector_Write(uint8 xdata *FlashAddress, uint8 FlashData)
  60          {
  61   1          bool TempEA;
  62   1      
  63   1          TempEA = EA;                       //Flash自烧写前先关总中断
  64   1          EA = 0;
  65   1      
  66   1        if(FlashAddress < 0x3f80)            // 不编程最后一个扇区,0X3F80~0X3FFF
  67   1          {
  68   2              FLA_CR = 0x01;                 // 使能Flash编程
  69   2              FLA_KEY = 0x5a;
  70   2              FLA_KEY = 0x1f;                // flash预编程解锁
  71   2              _nop_();
  72   2              *FlashAddress = FlashData;     // 写编程数据
  73   2              FLA_CR = 0x08;                 // 开始预编程，完成后Flash再次上锁
  74   2          }
  75   1      
  76   1          EA = TempEA;                       //Flash自烧写后总中断恢复 
  77   1      
  78   1          if(ReadBit(FLA_CR, FLAERR))
  79   1          {
  80   2              return 1;
  81   2          }
  82   1          else
  83   1          {
  84   2              return 0;
  85   2          }
  86   1          EA = EA;
  87   1      }
  88          
  89          /*-------------------------------------------------------------------------------------------------
  90            Function Name : void Flash_GetAddress(void)
  91            Description   : 读取Flash当前地址中的值
  92            Input         : null
  93            Output        : null
  94          -------------------------------------------------------------------------------------------------*/
  95          //uint8 Flash_GetAddress(void)
  96          //{
  97          //  uint8 i;
  98          //  __IO uint8 tevalue = 0;        //临时变量
  99          //  __IO uint8 revalue = 0;        //返回值
 100          
 101          //  revalue = 0;
 102          //  Rom.PageAddress = STARTPAGEROMADDRESS;
 103          //  
 104          //  tevalue = *(uint8 code *)Rom.PageAddress;
 105          //  
 106          //  while(tevalue != 0x7F)
 107          //  {
 108          //    Rom.PageAddress = Rom.PageAddress + 0x80; 
 109          //    tevalue = *(uint8 code *)Rom.PageAddress;
 110          //    
 111          //    if(Rom.PageAddress > 0x3F00)
 112          //    {
 113          //      Rom.PageAddress = STARTPAGEROMADDRESS;        
 114          //      revalue = 1;
C51 COMPILER V9.52.0.0   FLASH                                                             12/02/2025 15:24:49 PAGE 3   

 115          //      Rom.OffsetAddressCur = 0;
 116          //      Rom.OffsetAddressTar = Rom.OffsetAddressCur + 1;
 117          //      Flash_Sector_Write(Rom.PageAddress,0X7F); 
 118          //      tevalue = 0x7F;
 119          //    }      
 120          //  }
 121          
 122          //  for(i = 0; i < 128;i++)
 123          //  {
 124          //    tevalue = *(uint8 code *)(Rom.PageAddress + i);
 125          //    if(tevalue > 0)
 126          //    {
 127          //      Rom.OffsetAddressCur = i;
 128          //      Rom.OffsetAddressTar = Rom.OffsetAddressCur + 1;
 129          //      revalue = tevalue;
 130          //    }
 131          //  }
 132          
 133          //  return revalue;
 134          //}
 135          
 136          
 137          uint8 Flash_ErasePageRom(uint8 xdata *FlashAddress)
 138          {
 139   1          bool TempEA;
 140   1      
 141   1          TempEA = EA;
 142   1          EA = 0;
 143   1      
 144   1          if(FlashAddress < 0x3f80)       // 不擦除最后一个扇区
 145   1          {
 146   2              FLA_CR = 0x03;                                   //使能自擦除
 147   2              FLA_KEY = 0x5a;
 148   2              FLA_KEY = 0x1f;                                   //flash预编程解锁
 149   2              _nop_();
 150   2              *FlashAddress = 0xff;                   //写任意数据
 151   2              FLA_CR = 0x08;                                   //开始预编程，完成后Flash再次上锁
 152   2          }
 153   1      
 154   1          EA = TempEA;
 155   1          
 156   1          if(ReadBit(FLA_CR, FLAERR))
 157   1          {
 158   2              return 0;
 159   2          }
 160   1          else
 161   1          {
 162   2              return 1;
 163   2          }
 164   1      }
 165          
 166          void Write_Bytes_To_Flash(uint16 FlashAddress, uint8 *Buff, uint8 length)
 167          {                      
 168   1      
 169   1          uint16 i;
 170   1          uint8 FlashData = 0;
 171   1          uint8 sucess=1,sucess_temp=1;
 172   1          for (i = 0; i < length; i++)
 173   1          {
 174   2              FlashData = *Buff;
 175   2              sucess_temp=Flash_Sector_Write((FlashAddress + i), FlashData); //注意此处修改了原函数，
             -返回值1成功
C51 COMPILER V9.52.0.0   FLASH                                                             12/02/2025 15:24:49 PAGE 4   

 176   2              sucess= sucess & sucess_temp; //有1个0就不成功
 177   2              Buff++;
 178   2          }
 179   1          
 180   1                                                                         //读出有效数据
 181   1      }
 182          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    261    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7      11
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       3
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

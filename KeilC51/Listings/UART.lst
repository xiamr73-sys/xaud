C51 COMPILER V9.52.0.0   UART                                                              12/02/2025 15:24:50 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Output\UART.obj
COMPILER INVOKED BY: E:\tools\keil4\C51\BIN\C51.EXE ..\User\source\Hardware\UART.c LARGE OMF2 WARNINGLEVEL(0) BROWSE FLO
                    -ATFUZZY(4) INCDIR(..\User\include;..\FU68xx_Haidware_Driver\Include) DEBUG PRINT(.\Listings\UART.lst) TABS(2) OBJECT(.\O
                    -utput\UART.obj)

line level    source

   1          /*  --------------------------- (C) COPYRIGHT 2020 Fortiortech ShenZhen -----------------------------
   2              File Name      : UART.c
   3              Author         : Fortiortech  Appliction Team
   4              Version        : V1.0
   5              Date           : 2020-04-11
   6              Description    : This file contains .C file function used for Motor Control.
   7              ----------------------------------------------------------------------------------------------------
   8                                                 All Rights Reserved
   9              ------------------------------------------------------------------------------------------------- */
  10          #include <FU68xx_2.h>
  11          #include "Myproject.h"
  12          
  13          MCUART Uart;
  14          SELFLEARN Learn;
  15          SELFLEARN Power;
  16          UART_FLAG xdata UARTFL;
  17          extern int32  speedRef;
  18          uint8 Flash_Data[6]={0};
  19          
  20          //extern  uint16 xdata Speed_Level_flag;
  21          //extern bit Count1s_flag;
  22          //extern uint32 xdata Time_Keep;
  23          bit Control_ture = 0;
  24          bit  Send_Overflag = 1;
  25          bit uatr1s_flag = 0;
  26          float MinAngleLim = 34.0;
  27          float MaxAngleLim = 234.0;
  28          
  29          
  30          uint16 MinAngleCode  = (0x2FA << 2); //306
  31          uint16 MaxAngleCode  = (0x14D9 << 2); //14CD
  32          uint16 MiddleAngleCode  = (0x0BE9 << 2);
  33          
  34          uint16 lightSwitch  = (0x1467 << 2);
  35          
  36          /*  ----------------------------------------------------------------------------------------------*/
  37          /*  Function Name  : UART2_Init
  38              /*  Description    : UART2_Init
  39              /*  Date           : 2020-09-06
  40              /*  Parameter      : None
  41              /*  ----------------------------------------------------------------------------------------------*/
  42          void UART2_Init(void)
  43          {
  44   1          SetBit(PH_SEL, UART2EN);    //P3[6]as UART2_RXD; P3[7]as UART2_TXD
  45   1          #if 0
                  ClrBit(P3_OE, P36);         //ËæìÂÖ•‰ΩøËÉΩ
                  SetBit(P3_PU, P36);         //‰∏äÊãâÁîµÈòª
                  SetBit(P3_OE, P37);         //ËæìÂá∫‰ΩøËÉΩ
                  SetBit(P3_PU, P37);         //‰∏äÊãâÁîµÈòª
                  #endif
  51   1          ClrBit(UT2_CR, UT2MOD1);    //00-->ÂçïÁ∫øÂà∂8bit        01-->8bit uart(Ê≥¢ÁâπÁéáÂèØËÆæÁΩÆ)
  52   1          SetBit(UT2_CR, UT2MOD0);    //10-->ÂçïÁ∫øÂà∂9bit        11-->9bit uart(Ê≥¢ÁâπÁéáÂèØËÆæÁΩÆ)
  53   1          ClrBit(UT2_CR, UT2SM2);     //0-->ÂçïÊú∫ÈÄöËÆØ          1-->Â§öÊú∫ÈÄöËÆØÔºõ
C51 COMPILER V9.52.0.0   UART                                                              12/02/2025 15:24:50 PAGE 2   

  54   1          //    SetBit(UT2_CR, UT2REN);     //0-->‰∏çÂÖÅËÆ∏‰∏≤Ë°åËæìÂÖ• 1-->ÂÖÅËÆ∏‰∏≤Ë°åËæìÂÖ•ÔºåËΩØ‰ª∂Ê∏Ö0;
  55   1          ClrBit(UT2_CR, UT2TB8);     //Ê®°Âºè2/3‰∏ãÊï∞ÊçÆÂèëÈÄÅÁ¨¨9‰ΩçÔºåÂú®Â§öÊú∫ÈÄö‰ø°‰∏≠ÔºåÂèØÁî®‰∫éÂà§Êñ≠ÂΩ
             -ìÂâçÊï∞ÊçÆÂ∏ßÁöÑÊï∞ÊçÆÊòØÂú∞ÂùÄËøòÊòØÊï∞ÊçÆÔºåTB8=0‰∏∫Êï∞ÊçÆÔºåTB8=1‰∏∫Âú∞ÂùÄ
  56   1          ClrBit(UT2_CR, UT2RB8);     //Ê®°Âºè2/3‰∏ãÊï∞ÊçÆÊé•Êî∂Á¨¨9‰ΩçÔºåËã•SM2=0,‰Ωú‰∏∫ÂÅúÊ≠¢‰Ωç
  57   1          ClrBit(UT2_CR, UT2TI);
  58   1          ClrBit(UT2_CR, UT2RI);
  59   1          SetBit(UT2_CR, UT2REN);     //0-->‰∏çÂÖÅËÆ∏‰∏≤Ë°åËæìÂÖ• 1-->ÂÖÅËÆ∏‰∏≤Ë°åËæìÂÖ•ÔºåËΩØ‰ª∂Ê∏Ö0;
  60   1          PSPI_UT21 = 0;              //‰∏≠Êñ≠‰ºòÂÖàÁ∫ßÊó∂ÊúÄ‰Ωé
  61   1          PSPI_UT20 = 0;
  62   1          UT2_BAUD = 0x9B;      //Ê≥¢ÁâπÁéáÂèØËÆæÁΩÆ = 24000000/(16/(1+ UT_BAUD[BAUD_SEL]))/(UT_BAUD+1)
  63   1          //9B-->9600 0x000c-->115200 0x0005-->256000  4800-0x137;2400-0x270;1200-0x4E1
  64   1          ClrBit(UT2_BAUD, BAUD2_SEL); //ÂÄçÈ¢ë‰ΩøËÉΩ0-->Disable  1-->Enable
  65   1          SetBit(UT2_BAUD, UART2CH);   //UART2Á´ØÂè£ÂäüËÉΩËΩ¨Áßª‰ΩøËÉΩ0ÔºöP36->RXD P37->TXD 1:P01->RXD P00->TXD
  66   1          SetBit(UT2_BAUD, UART2IEN);  //UART2‰∏≠Êñ≠‰ΩøËÉΩ0-->Disable  1-->Enable
  67   1      }
  68          
  69          
  70          /*  ----------------------------------------------------------------------------------------------*/
  71          /*  Function Name  : UART1_Init
  72              /*  Description    : UART1_Init
  73              /*  Date           : 2020-09-06
  74              /*  Parameter      : None
  75              /*  ----------------------------------------------------------------------------------------------*/
  76          void UART1_Init(void)
  77          {
  78   1          SetBit(PH_SEL, UART1EN);    //P0[6]as UART2_RXD; P0[5]as UART2_TXD
  79   1          #if 0
                  ClrBit(P0_OE, P06);         //ËæìÂÖ•‰ΩøËÉΩ
                  SetBit(P0_PU, P06);         //‰∏äÊãâÁîµÈòª
                  SetBit(P0_OE, P05);         //ËæìÂá∫‰ΩøËÉΩ
                  SetBit(P0_PU, P05);         //‰∏äÊãâÁîµÈòª
                  #endif
  85   1          UT_MOD1 = 0;    //00-->ÂçïÁ∫øÂà∂8bit        01-->8bit uart(Ê≥¢ÁâπÁéáÂèØËÆæÁΩÆ)
  86   1          UT_MOD0 = 1;    //10-->ÂçïÁ∫øÂà∂9bit        11-->9bit uart(Ê≥¢ÁâπÁéáÂèØËÆæÁΩÆ)
  87   1          SM2 = 0;        //0-->ÂçïÊú∫ÈÄöËÆØ          1-->Â§öÊú∫ÈÄöËÆØÔºõ
  88   1          REN = 1;        //0-->‰∏çÂÖÅËÆ∏‰∏≤Ë°åËæìÂÖ• 1-->ÂÖÅËÆ∏‰∏≤Ë°åËæìÂÖ•ÔºåËΩØ‰ª∂Ê∏Ö0;
  89   1          TB8 = 0;        //Ê®°Âºè2/3‰∏ãÊï∞ÊçÆÂèëÈÄÅÁ¨¨9‰ΩçÔºåÂú®Â§öÊú∫ÈÄö‰ø°‰∏≠ÔºåÂèØÁî®‰∫éÂà§Êñ≠ÂΩìÂâçÊï∞ÊçÆÂ∏
             -ßÁöÑÊï∞ÊçÆÊòØÂú∞ÂùÄËøòÊòØÊï∞ÊçÆÔºåTB8=0‰∏∫Êï∞ÊçÆÔºåTB8=1‰∏∫Âú∞ÂùÄ
  90   1          RB8 = 0;        //Ê®°Âºè2/3‰∏ãÊï∞ÊçÆÊé•Êî∂Á¨¨9‰ΩçÔºåËã•SM2=0,‰Ωú‰∏∫ÂÅúÊ≠¢‰Ωç
  91   1          PI2C_UT11 = 0;                 //‰∏≠Êñ≠‰ºòÂÖàÁ∫ßÊó∂ÊúÄ‰Ωé
  92   1          PI2C_UT10 = 0;
  93   1          ClrBit(UT_BAUD, UART_2xBAUD);   //ÂÄçÈ¢ë‰ΩøËÉΩ0-->Disable  1-->Enable
  94   1          ES0 = 0;                        //UART1‰∏≠Êñ≠‰ΩøËÉΩ0-->Disable  1-->Enable
  95   1          UT_BAUD = 0x009B;//Ê≥¢ÁâπÁéáÂèØËÆæÁΩÆ = 24000000/(16/(1+ UT_BAUD[BAUD_SEL]))/(UT_BAUD+1)
  96   1          //9B-->9600 0x000c-->115200
  97   1      }
  98          
  99          float spd;
 100          extern int16 Speed_lim;
 101          
 102          uint8 PosErrSET;
 103          
 104          void Speed_Handle(uint8 level)
 105          {
 106   1          if (level >= 0x90)
 107   1          {
 108   2              level = 0x90;
 109   2          }
 110   1          else if (level <= 0x00)
 111   1          {
 112   2              level = 0x00;
 113   2          }
C51 COMPILER V9.52.0.0   UART                                                              12/02/2025 15:24:50 PAGE 3   

 114   1          
 115   1          //  spd = level * 0.75 + 2; //rpm ->¬∞/s //0.82*level+0.333
 116   1          spd = level * 0.83 + 0.333;
 117   1          Uart.Speed_Level = level;
 118   1          mcSpeedRampLim.IncValue = 60;
 119   1          mcSpeedRampLim.DecValue = 60;
 120   1       
 121   1          /***********************ÊØèÊ¨°ËÆæÂÆöÈÄüÂ∫¶ÈôêÂà∂Êó∂ÈáçÊñ∞ËßÑÂàíÊõ≤Á∫ø**********************/
 122   1          mcFocCtrl.SpeedRefLim = S_Value(spd);
 123   1          mcSpeedRampLim.TargetValue = S_Value(spd);
 124   1          //
 125   1          mcSpeedRampLim.ActualValue  = 0;
 126   1          mcSpeedRampLim.ActualValueFlt  = 0;
 127   1          mcSpeedRampLim.ActualValueFlt_LSB = 0;
 128   1      }
 129          
 130          
 131          void UartTxdate(uint16 * sndBuf, int32 len)
 132          {
 133   1          uint16 i = 0;
 134   1          
 135   1          for (i = 0; i < len; i++)
 136   1          {
 137   2              UART_SendData(*sndBuf++);
 138   2          }
 139   1      }
 140          void UART_SendData(unsigned char T_Data)
 141          {
 142   1      //  Wait_DMA(1);
 143   1      //  
 144   1      //  DMA1_LEN=Uart.T_Len-1;
 145   1      //    Switch_DMA(1);
 146   1        
 147   1          UT2_DR = T_Data;
 148   1          
 149   1          while (!(ReadBit(UT2_CR, UT2TI)));     //Á≠âÂæÖÂèëÈÄÅÂÆåÊàê
 150   1         
 151   1              TI = 0;                 //ÂèëÈÄÅÂÆåÊàê‰∏≠Êñ≠Ê†áÂøó‰ΩçÊ∏ÖÈõ∂
 152   1      }
 153          
 154          void Send_NoActive(void) //Êó†ÊïàÊåá‰ª§
 155          {
 156   1          Uart.T_DATA[0] = 0x90;
 157   1          Uart.T_DATA[1] = 0x51;
 158   1          Uart.T_DATA[2] = 0xFF;
 159   1          Uart.SendCnt = 0;
 160   1          Uart.T_Len = 3;
 161   1          UART_SendData(Uart.T_DATA[0]);
 162   1      }
 163          
 164          void Send_ACK(void)
 165          {
 166   1          Uart.T_DATA[0] = 0x90;
 167   1          Uart.T_DATA[1] = 0x40;
 168   1          Uart.T_DATA[2] = 0xFF;
 169   1          Uart.SendCnt = 0;
 170   1          Uart.T_Len = 3;
 171   1          UART_SendData(Uart.T_DATA[0]);
 172   1      }
 173          
 174          void Send_Success(void)
 175          {
C51 COMPILER V9.52.0.0   UART                                                              12/02/2025 15:24:50 PAGE 4   

 176   1          Uart.T_DATA[0] = 0x90;
 177   1          Uart.T_DATA[1] = 0x50;
 178   1          Uart.T_DATA[2] = 0xFF;
 179   1          Uart.SendCnt = 0;
 180   1          Uart.T_Len = 3;
 181   1          UART_SendData(Uart.T_DATA[0]);
 182   1      }
 183          
 184          void Send_Fail(void)
 185          {
 186   1          Uart.T_DATA[0] = 0x90;
 187   1          Uart.T_DATA[1] = 0x60;
 188   1          Uart.T_DATA[2] = 0x41;
 189   1          Uart.T_DATA[3] = 0xFF;
 190   1          Uart.SendCnt = 0;
 191   1          Uart.T_Len = 4;
 192   1          UART_SendData(Uart.T_DATA[0]);
 193   1      }
 194          
 195          
 196          
 197          /***************Â§ÑÁêÜ‰∏≤Âè£ÂèëÈÄÅÁöÑÊï∞ÊçÆ************/
 198          void UartDealResponse(void)
 199          {
 200   1          Uart.T_DATA[0] = 0x90;
 201   1          Uart.T_DATA[1] = 0x50;
 202   1          Uart.T_DATA[Uart.T_Len - 1] = 0xFF;
 203   1          Uart.SendCnt = 0;
 204   1          UART_SendData(Uart.T_DATA[0]);
 205   1      }
 206          
 207          
 208          
 209          
 210          uint8 singal = 0;
 211          
 212          int16 DelataWithSpeed = 0;
 213          int16 VToalDelat;
 214          
 215          uint8 TimeTounch ;
 216          
 217          void StopCurve(void)
 218          {
 219   1      
 220   1      }
 221          
 222          
 223          extern int32 PosErr;
 224          
 225          /***************Â§ÑÁêÜ‰∏≤Âè£Êé•Êî∂Âà∞ÁöÑÊï∞ÊçÆ************/
 226          uint16  Coordinate = 0;
 227          uint16  CoordinateLast = 0;
 228          
 229          uint16  PosiAngle = 0;
 230          uint32  PosiAngleSum = 0;
 231          
 232          
 233          int16 TempBaisL = 0;
 234          int16 TempBaisR = 0;
 235          int16 TempBaisWidth = 0;
 236          
 237          uint8 TurnDir = 0x00;
C51 COMPILER V9.52.0.0   UART                                                              12/02/2025 15:24:50 PAGE 5   

 238          
 239          void UartDealComm(void)
 240          {
 241   1           if (Uart.ResponceFlag == 1)
 242   1          {
 243   2              switch (Uart.R_DATA[1])
 244   2              {            
 245   3                  case 0x02:
 246   3                      switch (Uart.R_DATA[2])
 247   3                      {
 248   4                          case 0x38:                        
 249   4                              
 250   4                              Uart.T_DATA[0] = 0x90;
 251   4                              Uart.T_DATA[1] = 0x50;
 252   4                              Uart.T_DATA[2] = 0x01;
 253   4                              Uart.T_DATA[3] = 0x00;
 254   4                        
 255   4                              Uart.T_Len = 5;
 256   4                              Uart.RxFSM = 1;
 257   4                              
 258   4                              break;
 259   4                          
 260   4                      }
 261   3                      break;
 262   3              }
 263   2              if (Uart.RxFSM == 1)
 264   2              {
 265   3                  UartDealResponse();
 266   3                  Uart.RxFSM = 0;
 267   3              }
 268   2              Uart.ResponceFlag = 0;
 269   2          }
 270   1      }
 271          
 272          
 273          void UartDealComm2(void)
 274          {
 275   1          if (Uart.ResponceFlag == 1)
 276   1          {
 277   2      
 278   2              switch (Uart.R_DATA[1])
 279   2              {
 280   3                  case 0x01:
 281   3                  
 282   3                      /**********************Áõ¥Êé•ÂõûÂ§çACK************************/
 283   3                      Send_ACK();
 284   3                      Uart.RxFSM = 1;
 285   3                      switch (Uart.R_DATA[3])
 286   3                      {
 287   4                          case 0x01:
 288   4                              if ((Uart.R_DATA[5]  == 0x05) && (Uart.R_DATA[6]  == 0x05))
 289   4                              {
 290   5                                  MOE = 0;
 291   5                                  GP44 = 1;
 292   5                              }
 293   4                              else if ((Uart.R_DATA[5]  == 0x06) && (Uart.R_DATA[6]  == 0x06))
 294   4                              {
 295   5                                  GP44 = 1;
 296   5                                  SetBit(RST_SR , SOFTR);
 297   5                                  MOE = 1;
 298   5                              }
 299   4                              break;
C51 COMPILER V9.52.0.0   UART                                                              12/02/2025 15:24:50 PAGE 6   

 300   4                          case 0x02://ÂçïÂúà‰ΩçÁΩÆÈó≠ÁéØÊéßÂà∂ÂëΩ‰ª§81 01 06 02 XX 0V 0V 0V 0V 02 03 FF
 301   4                              Speed_Handle(Uart.R_DATA[4]);
 302   4                              PosiAngle = (Uart.R_DATA[5] << 12) + (Uart.R_DATA[6] << 8) + (Uart.R_DATA[7] << 4)
             - + Uart.R_DATA[8];
 303   4                              mcQEP.ZSaveFlag = 0;
 304   4                              UqPo.UqPoaiFlag = 0;
 305   4                              UqPo.UqPosiLockFlag = 1;
 306   4                              mcFocCtrl.ThetaIQ_SOURCE = 0;
 307   4                              if ((Uart.R_DATA[9]  == 0x03) && (Uart.R_DATA[10]  == 0x02))
 308   4                              {
 309   5                                  mcSP.PulsesNum =  (PosiAngle) + mcQEP.ZeroCntr + mcQEP.ZeroNewCntr;
 310   5                                  if (mcSP.PulsesNum < mcQEP.CntrSumReal - 20)
 311   5                                  {
 312   6                                      mcSP.PulsesNum += 65536;
 313   6                                  }
 314   5                                  if(Uart.R_DATA[5] == 0x03)
 315   5                                  {
 316   6                                    UARTFL.flag_90 = 1;
 317   6                                  }
 318   5                                  else if(Uart.R_DATA[5] == 0x07)
 319   5                                  {
 320   6                                    UARTFL.flag_180 = 1;
 321   6                                  }
 322   5                                  else if(Uart.R_DATA[5] == 0x0B)
 323   5                                  {
 324   6                                    UARTFL.flag_270 = 1;
 325   6                                  }
 326   5                                  else if(Uart.R_DATA[5] == 0x0F)
 327   5                                  {
 328   6                                    UARTFL.flag_0 = 1;
 329   6                                  }
 330   5                              }
 331   4                              else if ((Uart.R_DATA[10]  == 0x03) && (Uart.R_DATA[9]  == 0x02))
 332   4                              {
 333   5                                  mcSP.PulsesNum = -(65536 -(int32)(PosiAngle)) + mcQEP.ZeroCntr + mcQEP.ZeroNew
             -Cntr; //4096Á∫ø*4 = 16383 = ‰∏ÄÂúàÔºåÂèçËΩ¨
 334   5                                  if (mcSP.PulsesNum > mcQEP.CntrSumReal + 20)
 335   5                                  {
 336   6                                      mcSP.PulsesNum -= 65536;
 337   6                                  }
 338   5                              }
 339   4                              
 340   4                              //Speed_Handle(Uart.R_DATA[4]);
 341   4                              break;
 342   4                              
 343   4                          case 0x03://Â¢ûÈáè‰ΩçÁΩÆÈó≠ÁéØÊéßÂà∂ÂëΩ‰ª§
 344   4                              Speed_Handle(Uart.R_DATA[4]);
 345   4                              PosiAngleSum = (int32)(((int32)Uart.R_DATA[5] << 28) + ((int32)Uart.R_DATA[6] << 2
             -4) + ((int32)Uart.R_DATA[7] << 20) + ((int32)Uart.R_DATA[8] << 16)+ ((int32)Uart.R_DATA[9] << 12)+ ((int32)Uart.R_DATA[1
             -0] << 8)+ ((int32)Uart.R_DATA[11] << 4) + (int32)Uart.R_DATA[12]);
 346   4                              
 347   4                              //Speed_Handle(Uart.R_DATA[4]);
 348   4                              if ((Uart.R_DATA[9]  == 0x02) && (Uart.R_DATA[10]  == 0x03))
 349   4                              {
 350   5                                  mcSP.PulsesNum =  mcQEP.CntrSumReal - (PosiAngleSum >> 2);
 351   5                              }
 352   4                              else if ((Uart.R_DATA[10]  == 0x02) && (Uart.R_DATA[9]  == 0x03))
 353   4                              {
 354   5                                  mcSP.PulsesNum =  mcQEP.CntrSumReal + (PosiAngleSum >> 2);
 355   5                              }
 356   4                              
 357   4                              break;
C51 COMPILER V9.52.0.0   UART                                                              12/02/2025 15:24:50 PAGE 7   

 358   4                              
 359   4                          case 0x04:
 360   4      //                        Speed_Handle(0x05);
 361   4      //                        if ((mcQEP.ZeroCntrOld  < mcQEP.ZeroCntr) && (mcQEP.ZeroNewCntr > 0x1FFF))
 362   4      //                        {
 363   4      //                            mcSP.PulsesNum = mcQEP.ZeroCntrOld + mcQEP.ZeroNewCntr;
 364   4      //                        }
 365   4      //                        else 
 366   4      //                        {
 367   4                                  mcSP.PulsesNum = mcQEP.ZeroCntr + mcQEP.ZeroNewCntr;
 368   4      //                        }
 369   4                              break;
 370   4                              
 371   4                          case 0x08://ÂÜôÈõ∂‰Ωç81 01 06 08 FF
 372   4                               //mcQEP.CntrSum_ZeroTemp = mcQEP.CntrSumReal;
 373   4      //                        Speed_Handle(0x05);
 374   4                              mcQEP.ZeroNewCntr = mcQEP.CntrSumReal - mcQEP.ZeroCntr;
 375   4                              Flash_Data[0] = mcQEP.AngleFlt >> 8;
 376   4                              Flash_Data[1] = mcQEP.AngleFlt;
 377   4                              Flash_Data[2] = mcQEP.ZeroNewCntr >> 24;
 378   4                              Flash_Data[3] = mcQEP.ZeroNewCntr >> 16;
 379   4                              Flash_Data[4] = mcQEP.ZeroNewCntr >> 8;
 380   4                              Flash_Data[5] = mcQEP.ZeroNewCntr;
 381   4                              EA = 0;
 382   4                              Flash_ErasePageRom(STARTPAGEROMADDRESS);
 383   4                              
 384   4                              Flash_Sector_Write(STARTPAGEROMADDRESS, Flash_Data[0]);
 385   4                              Flash_Sector_Write(STARTPAGEROMADDRESS+1, Flash_Data[1]);
 386   4                              Flash_Sector_Write(STARTPAGEROMADDRESS+2, Flash_Data[2]);
 387   4                              Flash_Sector_Write(STARTPAGEROMADDRESS+3, Flash_Data[3]);
 388   4                              Flash_Sector_Write(STARTPAGEROMADDRESS+4, Flash_Data[4]);
 389   4                              Flash_Sector_Write(STARTPAGEROMADDRESS+5, Flash_Data[5]);
 390   4                              EA = 1;
 391   4                              
 392   4                              break;
 393   4                              
 394   4                          case 0x22://ÁîµÊú∫ÂÅúÊ≠¢ÂëΩ‰ª§„ÄÇ81 01 06 22 FF
 395   4                              if (Uart.UsaRxLen == 6)
 396   4                              {
 397   5                                isCtrlPowerOn = false;
 398   5                                Uart.T_Len = 3;
 399   5                                Uart.RxFSM = 1;
 400   5                              }
 401   4                          case 0x33://ÁîµÊú∫ÂêØÂä®ÂëΩ‰ª§„ÄÇ81 01 06 33 FF
 402   4                              if (Uart.UsaRxLen == 6)
 403   4                              {
 404   5                                isCtrlPowerOn = true;
 405   5                                Uart.T_Len = 3;
 406   5                                Uart.RxFSM = 1;
 407   5                              }
 408   4                              break;
 409   4                              
 410   4                          default:
 411   4                              break;
 412   4                      }
 413   3                      
 414   3                      break;
 415   3                      //            default:
 416   3                      //                break;
 417   3                  
 418   3                  case 0x02:
 419   3                      switch (Uart.R_DATA[2])
C51 COMPILER V9.52.0.0   UART                                                              12/02/2025 15:24:50 PAGE 8   

 420   3                      {
 421   4                          case 0x38:                        
 422   4                              
 423   4                              Uart.T_DATA[0] = 0x90;
 424   4                              Uart.T_DATA[1] = 0x50;
 425   4                              Uart.T_DATA[2] = 0x01;
 426   4                              Uart.T_DATA[3] = 0x00;
 427   4                        
 428   4                              Uart.T_Len = 5;
 429   4                              Uart.RxFSM = 1;
 430   4                              
 431   4                              break;
 432   4                          
 433   4                          case 0x48:
 434   4                                  
 435   4                              Uart.T_DATA[0] = 0x90;
 436   4                              Uart.T_DATA[1] = 0x50;
 437   4                              Uart.T_DATA[2] = 0x01;
 438   4                              Uart.T_DATA[3] = 0x00;
 439   4                        
 440   4                              Uart.T_Len = 5;
 441   4                              Uart.RxFSM = 1;
 442   4                              
 443   4                              break;
 444   4                          
 445   4                          case 0x68:
 446   4                              
 447   4                              Uart.T_DATA[0] = 0x90;
 448   4                              Uart.T_DATA[1] = 0x50;
 449   4                              Uart.T_DATA[2] = (SKP >> 4) & 0x0F;
 450   4                              Uart.T_DATA[3] = SKP;
 451   4                              
 452   4                              Uart.T_Len = 5;
 453   4                              Uart.RxFSM = 1;
 454   4                          
 455   4                              break;
 456   4                         case 0x69:
 457   4                              
 458   4                              Uart.T_DATA[0] = 0x90;
 459   4                              Uart.T_DATA[1] = 0x50;
 460   4                              Uart.T_DATA[2] = (SKI >> 4) & 0x0F;
 461   4                              Uart.T_DATA[3] = SKI;
 462   4                              
 463   4                              Uart.T_Len = 5;
 464   4                              Uart.RxFSM = 1;
 465   4                          
 466   4                              break;
 467   4                         
 468   4                          case 0x6A:
 469   4                              
 470   4                              Uart.T_DATA[0] = 0x90;
 471   4                              Uart.T_DATA[1] = 0x50;
 472   4                              Uart.T_DATA[2] = (SKD >> 4) & 0x0F;
 473   4                              Uart.T_DATA[3] = SKD;
 474   4                          
 475   4                              Uart.T_Len = 5;
 476   4                              Uart.RxFSM = 1;
 477   4                          
 478   4                              break;
 479   4                          
 480   4                         case 0x78:
 481   4                              
C51 COMPILER V9.52.0.0   UART                                                              12/02/2025 15:24:50 PAGE 9   

 482   4                              Uart.T_DATA[0] = 0x90;
 483   4                              Uart.T_DATA[1] = 0x50;
 484   4                              if (mcState != mcFault)
 485   4                              {
 486   5                                  Uart.T_DATA[2] = 0x05;                          
 487   5                              }
 488   4                              else 
 489   4                              {
 490   5                                  Uart.T_DATA[2] = 0x04;
 491   5                              } 
 492   4                              
 493   4                              Uart.T_Len = 4;
 494   4                              Uart.RxFSM = 1;
 495   4                          
 496   4                              break;
 497   4                              
 498   4                        case 0x88:
 499   4                                                
 500   4      //                        mcFaultSource = FaultNoSource;
 501   4                              mcFaultDect.CurrentFlag = 0;
 502   4      
 503   4                              Uart.T_DATA[0] = 0x90;
 504   4                              Uart.T_DATA[1] = 0x50;
 505   4                              if (mcState != mcFault)
 506   4                              {
 507   5                                  
 508   5                                  Uart.T_DATA[2] = 0x06; 
 509   5                                  
 510   5                              }
 511   4                              else 
 512   4                              {
 513   5                                  Uart.T_DATA[2] = 0x04;
 514   5                              } 
 515   4                              Uart.T_Len = 4;
 516   4                              Uart.RxFSM = 1;
 517   4      
 518   4                          
 519   4                              break;
 520   4                      }
 521   3                      break;
 522   3                      
 523   3                  case 0x09:
 524   3                      switch (Uart.R_DATA[2])
 525   3                      {
 526   4                          case 0x04:
 527   4                              Uart.T_DATA[0] = 0x90;
 528   4                              Uart.T_DATA[1] = 0x50;
 529   4                              if (Learn.FilishFlag)
 530   4                              {
 531   5                                  Uart.T_DATA[2] = 0x02;                          
 532   5                              }
 533   4                              else 
 534   4                              {
 535   5                                  Uart.T_DATA[2] = 0x03;
 536   5                              }
 537   4                              
 538   4                              Uart.T_Len = 4;
 539   4                              Uart.RxFSM = 1;
 540   4                              break;
 541   4                          
 542   4                          case 0x06:                      
 543   4                              switch (Uart.R_DATA[3])
C51 COMPILER V9.52.0.0   UART                                                              12/02/2025 15:24:50 PAGE 10  

 544   4                              {
 545   5                                  case 0x11:
 546   5                                          mcSP.Speedlevel = (float)(ABS(mcQEP.SpeedMFlt) * MOTOR_SPEED_BASE / 32
             -767.0 - 0.333)/0.833;
 547   5      
 548   5                                          
 549   5                                          Uart.T_DATA[0] = 0x90;
 550   5                                          Uart.T_DATA[1] = 0x50;
 551   5                                          Uart.T_DATA[2] = 0x11;
 552   5                                          Uart.T_DATA[3] = mcSP.Speedlevel;
 553   5                                    
 554   5                                          Uart.T_Len = 5;
 555   5                                          Uart.RxFSM = 1;
 556   5                                      
 557   5                                      break;
 558   5                                  
 559   5                                  case 0x12:
 560   5                                          PosiAngle = mcQEP.CntrSumReal - mcQEP.ZeroCntr - mcQEP.ZeroNewCntr;
 561   5                                         // PosiAngle = PosiAngle << 2;
 562   5                                          Uart.T_DATA[0] = 0x90;
 563   5                                          Uart.T_DATA[1] = 0x50;
 564   5                                          Uart.T_DATA[2] = (PosiAngle >> 12) & 0x0F;
 565   5                                          Uart.T_DATA[3] = (PosiAngle >> 8) & 0x0F;
 566   5                                          Uart.T_DATA[4] = (PosiAngle >> 4) & 0x0F;
 567   5                                          Uart.T_DATA[5] = PosiAngle & 0x0F;
 568   5                                    
 569   5                                          Uart.T_Len = 7;
 570   5                                          Uart.RxFSM = 1;
 571   5                                      
 572   5                                      break;
 573   5                              }
 574   4                              break;
 575   4                      }
 576   3                      break;
 577   3              }
 578   2              if (Uart.RxFSM == 1)
 579   2              {
 580   3                  UartDealResponse();
 581   3                  Uart.RxFSM = 0;
 582   3              }
 583   2              Uart.ResponceFlag = 0;
 584   2          }
 585   1          
 586   1          
 587   1      }
 588          
 589          
 590          
 591          
 592          void Fault_Communication(void)
 593          {
 594   1          if (Uart.Read_State)
 595   1          {
 596   2              if (Uart.Time_Count < 200) //100 ms
 597   2              {
 598   3                  Uart.Time_Count++;
 599   3              }
 600   2              else
 601   2              {
 602   3                  Uart.UARxCnt = 0;
 603   3                  Uart.Read_State = 0;
 604   3                  Uart.ResponceFlag = 0;
C51 COMPILER V9.52.0.0   UART                                                              12/02/2025 15:24:50 PAGE 11  

 605   3              }
 606   2          }
 607   1          else
 608   1          {
 609   2              Uart.Time_Count = 0;
 610   2          }
 611   1      }
 612          
 613          
 614          
 615          
 616          
 617          void Self_Learning(void)
 618          {
 619   1        if (Learn.State != LearnOver)
 620   1        {
 621   2          mcSP.PulsesNum = mcQEP.CntrSumReal + 3000;
 622   2      //        mcSpeedRampLim.ActualValueFlt = 30000;
 623   2          isCtrlPowerOn = true;
 624   2          if (mcQEP.ZSaveFlag ==1)
 625   2          {
 626   3            //isCtrlPowerOn = false;
 627   3            Learn.State = LearnOver;
 628   3          }
 629   2        }
 630   1        else
 631   1        {
 632   2      //        speedRef =  S_Value(0.0);
 633   2      //        Speed_Handle(0x00);
 634   2            mcSP.PulsesNum = mcQEP.ZeroCntr + mcQEP.ZeroNewCntr;
 635   2      //          mcSP.PulsesNum = mcQEP.CntrSumReal;
 636   2                Learn.FilishFlag = 1;
 637   2      //    isCtrlPowerOn = true;
 638   2      //    mcSP.PulsesNum =8192;
 639   2        }
 640   1        
 641   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2800    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    172      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              12/02/2025 15:24:48 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MOTORCONTROLFUNCTION
OBJECT MODULE PLACED IN .\Output\MotorControlFunction.obj
COMPILER INVOKED BY: E:\tools\keil4\C51\BIN\C51.EXE ..\User\source\Function\MotorControlFunction.c LARGE OMF2 WARNINGLEV
                    -EL(0) BROWSE FLOATFUZZY(4) INCDIR(..\User\include;..\FU68xx_Haidware_Driver\Include) DEBUG PRINT(.\Listings\MotorControl
                    -Function.lst) TABS(2) OBJECT(.\Output\MotorControlFunction.obj)

line level    source

   1          /* --------------------------- (C) COPYRIGHT 2020 Fortiortech ShenZhen -----------------------------
   2              File Name      : MotorSpeedFunction.c
   3              Author         : Fortiortech  Appliction Team
   4              Version        : V1.0
   5              Date           : 2020-04-10
   6              Description    : This file contains .C file function used for Motor Control.
   7          ----------------------------------------------------------------------------------------------------
   8                                                 All Rights Reserved
   9          ------------------------------------------------------------------------------------------------- */
  10          #include <MyProject.h>
  11          
  12          CurrentOffset xdata mcCurOffset;
  13          bool OpenFlag;
  14          uint8 Data[4]={0};
  15          
  16          /* -------------------------------------------------------------------------------------------------
  17              Function Name  : FOC_Init
  18              Description    : mcInitçŠ¶æ€ä¸‹ï¼Œå¯¹FOCçš„ç›¸å…³å¯„å­˜å™¨è¿›è¡Œé…ç½®,å…ˆæ¸…ç†å¯„å­˜å™¨ï¼Œåé…ç½®
             -ï¼Œæœ€åä½¿èƒ½
  19              Date           : 2020-04-10
  20              Parameter      : None
  21          ------------------------------------------------------------------------------------------------- */
  22          void FOC_Init(void)//MOtor_Init
  23          {
  24   1          /*ä½¿èƒ½FOC*/
  25   1          ClrBit(DRV_CR, FOCEN);
  26   1          SetBit(DRV_CR, FOCEN);
  27   1          SetBit(FOC_CR0, ESCMS);
  28   1          ClrBit(FOC_CR0, MERRS1);
  29   1          SetBit(FOC_CR0, MERRS0);
  30   1          //    FOC_EOMEKLPF    = 0;
  31   1          //    FOC_KFG         = MCU_CLOCK * BASE_FREQ * FG_K);
  32   1          /*é…ç½®FOCå¯„å­˜å™¨*/
  33   1          FOC_CR1         = 0;                                    // æ¸…é›¶ FOC_CR1
  34   1          FOC_CR2         = 0;                                    // æ¸…é›¶ FOC_CR2
  35   1          FOC_IDREF       = 0;                                    // æ¸…é›¶ Id
  36   1          FOC_IQREF       = 0;                                    // æ¸…é›¶ Iq
  37   1          //    FOC__THETA      = 0;                                    // æ¸…é›¶ è§’åº¦
  38   1          FOC_RTHEACC     = 0;                                    // æ¸…é›¶ çˆ¬å¡å‡½æ•°çš„åˆå§‹åŠ é€Ÿåº¦
  39   1          FOC__RTHESTEP   = 0;                                    // æ¸…é›¶ çˆ¬å¡é€Ÿåº¦
  40   1          FOC_RTHECNT     = 0;                                    // æ¸…é›¶ çˆ¬å¡æ¬¡æ•°
  41   1          FOC_THECOMP     = _Q15(0.0 / 180.0);                    // SMO ä¼°ç®—è¡¥å¿è§’
  42   1          FOC_THECOR      = 0x04;                                 // è¯¯å·®è§’åº¦è¡¥å¿
  43   1          /*ç”µæµç¯å‚æ•°é…ç½®*/
  44   1          FOC_DMAX        = DOUTMAX;
  45   1          FOC_DMIN        = DOUTMIN;
  46   1          FOC_QMAX        = QOUTMAX;
  47   1          FOC_QMIN        = QOUTMIN;
  48   1          /*ä½ç½®ä¼°ç®—å‚æ•°é…ç½®*/
  49   1          //    FOC_FBASE       = OBS_FBASE;
  50   1          FOC_EBMFK       = OBS_KLPF;
  51   1          FOC_TGLI        = 0x00;
  52   1          SetBit(FOC_CR1, SVPWMEN);                               // SVPWMæ¨¡å¼
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              12/02/2025 15:24:48 PAGE 2   

  53   1          /**è¿‡è°ƒåˆ¶**/
  54   1          #if (OverModulation == 1)
                  {
                      SetBit(FOC_CR1, OVMDL);                             // è¿‡è°ƒåˆ¶
                  }
                  #endif //end OverModulation
  59   1          #if(VOLTAGE_MODE ==INTERNAL)
  60   1          {
  61   2              SetBit(FOC_CR0, UCSEL);
  62   2          }
  63   1          #else
                  {
                      ClrBit(FOC_CR0, UCSEL);
                  }
                  #endif
  68   1          
  69   1          SetBit(DRV_CR, DDIR);
  70   1          
  71   1          
  72   1          /*å•ç”µé˜»é‡‡æ ·ï¼›éœ€è¦æœ€å°é‡‡æ ·çª—,FOC_TRGDLYä¸º0ï¼Œä¸ƒæ®µå¼SVPWMæ–¹å¼*/
  73   1          #if (Shunt_Resistor_Mode == Single_Resistor)
                  {
                      SetReg(FOC_CR1, CSM0 | CSM1, 0x00);
                      FOC_TSMIN  = PWM_TS_LOAD;                           // æœ€å°é‡‡æ ·çª—å£
                      FOC_TRGDLY = 0x0F;                                  // é‡‡æ ·æ—¶åˆ»åœ¨ä¸­ç‚¹ï¼Œä¸€èˆ¬è€ƒè™‘å¼€å…³å
             -™ªå£°å½±å“ï¼Œä¼šè®¾ç½®å»¶è¿Ÿï¼›
                      // 0x0cè¡¨ç¤ºå»¶è¿Ÿ12ä¸ªclockï¼Œæå‰ç”¨åç å½¢å¼ï¼Œå¦‚0x84è¡¨ç¤ºæå‰12ä¸ªclockã€‚
                      ClrBit(FOC_CR2, F5SEG);                             // 7æ®µå¼
                      SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, 0x00);
                  }
                  /*åŒç”µé˜»é‡‡æ ·ï¼Œå¯è®¾ç½®æ­»åŒºè¡¥å¿å€¼ï¼Œåœ¨ä¸‹é™æ²¿ç»“æŸå‰å¼€å§‹é‡‡æ ·Iaï¼Œé…ç½®81*/
                  #elif (Shunt_Resistor_Mode == Double_Resistor)          // double resistor sample
  84   1          {
  85   2              SetReg(FOC_CR1, CSM0 | CSM1, CSM0);
  86   2              FOC_TSMIN = PWM_DT_LOAD;                            // æ­»åŒºè¡¥å¿å€¼
  87   2              FOC_TRGDLY = 0x82;                                  // ADCé‡‡æ ·çš„æ—¶åˆ»ï¼Œé‡‡æ ·æ—¶åˆ»åœ¨è®¡æ•°å
             -™¨é›¶ç‚¹é™„è¿‘ï¼Œ83ä¸ºä¸‹é™æ²¿ç»“æŸå‰3ä¸ªclocké‡‡æ ·Iaï¼Œä¸å•ç”µé˜»ä¸åŒ
  88   2              // 01ä¸ºä¸Šå‡æ²¿å¼€å§‹åç¬¬ä¸€ä¸ªclockå¼€å§‹é‡‡æ ·ã€‚æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ã€‚
  89   2              FOC_TBLO = PWM_DLOWL_TIME;                          //ä¸‹æ¡¥è‡‚æœ€å°è„‰å†²ï¼Œä¿è¯é‡‡æ ·
  90   2              SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, 0x00);
  91   2              /*äº”æ®µå¼æˆ–ä¸ƒæ®µå¼é€‰æ‹©*/
  92   2              #if (SVPMW_Mode == SVPWM_7_Segment)
  93   2              {
  94   3                  ClrBit(FOC_CR2, F5SEG);                         // 7æ®µå¼
  95   3              }
  96   2              #elif (SVPMW_Mode == SVPWM_5_Segment)
                      {
                          SetBit(FOC_CR2, F5SEG);                         // 5æ®µå¼
                      }
                      #endif
 101   2              #if (DouRes_Sample_Mode == DouRes_1_Cycle)
 102   2              {
 103   3                  ClrBit(FOC_CR2, DSS);                           // 7æ®µå¼
 104   3              }
 105   2              #elif (DouRes_Sample_Mode == DouRes_2_Cycle)
                      {
                          SetBit(FOC_CR2, DSS);                           // 5æ®µå¼
                      }
                      #endif //end DouRes_Sample_Mode
 110   2          }
 111   1          /*ä¸‰ç”µé˜»é‡‡æ ·*/
 112   1          #elif (Shunt_Resistor_Mode == Three_Resistor)           // signel resistor sample
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              12/02/2025 15:24:48 PAGE 3   

                  {
                      SetReg(FOC_CR1, CSM0 | CSM1, CSM0 | CSM1);          // ä¸‰ç”µé˜»
                      FOC_TSMIN  = PWM_DT_LOAD;                           // æ­»åŒºè¡¥å¿å€¼
                      FOC_TRGDLY = 0x06;                                  // ADCé‡‡æ ·çš„æ—¶åˆ»ï¼Œé‡‡æ ·æ—¶åˆ»åœ¨è®¡æ•°å
             -™¨é›¶ç‚¹é™„è¿‘ï¼Œ83ä¸ºä¸‹é™æ²¿ç»“æŸå‰3ä¸ªclocké‡‡æ ·Iaï¼Œä¸å•ç”µé˜»ä¸åŒã€‚
                      // 01ä¸ºä¸Šå‡æ²¿å¼€å§‹åç¬¬ä¸€ä¸ªclockå¼€å§‹é‡‡æ ·ã€‚æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ã€‚
                      SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, CMP3MOD0 | CMP3MOD1);
                      FOC_TBLO = PWM_OVERMODULE_TIME;                     // è¿‡è°ƒåˆ¶ç”µæµé‡‡æ ·å¤„ç†çš„TBè„‰å®½
                      /*äº”æ®µå¼æˆ–ä¸ƒæ®µå¼é€‰æ‹©*/
                      #if (SVPMW_Mode == SVPWM_7_Segment)
                      {
                          ClrBit(FOC_CR2, F5SEG);                         // 7æ®µå¼
                      }
                      #elif (SVPMW_Mode == SVPWM_5_Segment)
                      {
                          SetBit(FOC_CR2, F5SEG);                         // 5æ®µå¼
                      }
                      #endif //end SVPMW_Mode
                      #if (DouRes_Sample_Mode == DouRes_1_Cycle)
                      {
                          ClrBit(FOC_CR2, DSS);                           // 7æ®µå¼
                      }
                      #elif (DouRes_Sample_Mode == DouRes_2_Cycle)
                      {
                          SetBit(FOC_CR2, DSS);                           // 5æ®µå¼
                      }
                      #endif //end DouRes_Sample_Mode
                  }
                  #endif  //end Shunt_Resistor_Mode
 141   1          /* ä½¿èƒ½ç”µæµåŸºå‡†æ ¡æ­£ */
 142   1          #if (CalibENDIS == Enable)
 143   1          {
 144   2              if (mcCurOffset.OffsetFlag == 1)
 145   2              {
 146   3                  #if (Shunt_Resistor_Mode == Single_Resistor)    // å•ç”µé˜»æ ¡æ­£
                          {
                              /*set ibus current sample offset*/
                              SetReg(FOC_CR2, CSOC0 | CSOC1, 0x00);
                              FOC_CSO = mcCurOffset.Iw_busOffset;         // å†™å…¥Ibusçš„åç½®
                          }
                          #elif (Shunt_Resistor_Mode == Double_Resistor)  // åŒç”µé˜»æ ¡æ­£
 153   3                  {
 154   4                      /*set ia, ib current sample offset*/
 155   4                      SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC0);
 156   4                      FOC_CSO  = mcCurOffset.IuOffset;            // å†™å…¥IAçš„åç½®
 157   4                  
 158   4                      SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC1);
 159   4                      FOC_CSO  = mcCurOffset.IvOffset;            // å†™å…¥IBçš„åç½®
 160   4                  }
 161   3                  #elif (Shunt_Resistor_Mode == Three_Resistor)   // ä¸‰ç”µé˜»æ ¡æ­£
                          {
                              /*set ibus current sample offset*/
                              SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC0);
                              FOC_CSO = mcCurOffset.IuOffset;             // å†™å…¥IAçš„åç½®
                          
                              SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC1);
                              FOC_CSO = mcCurOffset.IvOffset;             // å†™å…¥IBçš„åç½®
                          
                              SetReg(FOC_CR2, CSOC0 | CSOC1, 0x00);
                              FOC_CSO = mcCurOffset.Iw_busOffset;         // å†™å…¥ICçš„åç½®
                          }
                          #endif  //end Shunt_Resistor_Mode
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              12/02/2025 15:24:48 PAGE 4   

 174   3              }
 175   2          }
 176   1          #endif  //end CalibENDIS
 177   1          /*-------------------------------------------------------------------------------------------------
 178   1          DRV_CTLï¼šPWMæ¥æºé€‰æ‹©
 179   1          OCS = 0, DRV_COMR
 180   1          OCS = 1, FOC/SVPWM/SPWM
 181   1          -------------------------------------------------------------------------------------------------*/
 182   1          /*è®¡æ•°å™¨æ¯”è¾ƒå€¼æ¥æºFOC*/
 183   1          SetBit(DRV_CR, OCS);
 184   1      }
 185          
 186          
 187          
 188          /* -------------------------------------------------------------------------------------------------
 189              Function Name  : Motor_Align
 190              Description    : é¢„å®šä½å‡½æ•°ï¼Œå½“æ— é€†é£åˆ¤æ–­æ—¶ï¼Œé‡‡ç”¨é¢„å®šä½å›ºå®šåˆå§‹ä½ç½®;å½“æœ‰é€†
             -é£åˆ¤æ–­æ—¶ï¼Œé‡‡ç”¨é¢„å®šä½åˆ¹è½¦
 191              Date           : 2020-04-10
 192              Parameter      : None
 193          ------------------------------------------------------------------------------------------------- */
 194          uint8 AlignFlag = 0;
 195          
 196          void Motor_Align(void)
 197          {
 198   1          if (McStaSet.SetFlag.AlignSetFlag == 0)
 199   1          {
 200   2              McStaSet.SetFlag.AlignSetFlag = 1;
 201   2              /* -----FOCåˆå§‹åŒ–----- */
 202   2              FOC_Init();
 203   2              /*é…ç½®é¢„å®šä½çš„ç”µå‹ã€KPã€KI*/
 204   2              FOC_IDREF = ID_Align_CURRENT;
 205   2              FOC_IQREF = IQ_Align_CURRENT;               //å®šä¹‰ç”µå‹
 206   2              //        SetBit(FOC_CR2, UDD);
 207   2              //        SetBit(FOC_CR2, UQD);
 208   2              FOC_DQKP  = DQKP_Alignment;
 209   2              FOC_DQKI  = DQKI_Alignment;
 210   2              /* é…ç½®é¢„å®šä½è§’åº¦ */
 211   2              FOC__THETA  = Align_Theta;
 212   2              /*********PLLæˆ–SMO**********/
 213   2              #if (EstimateAlgorithm == SMO)
 214   2              {
 215   3                  FOC__ETHETA   = FOC__THETA - 4096;
 216   3              }
 217   2              #elif (EstimateAlgorithm == PLL)
                      {
                          FOC__ETHETA   = FOC__THETA;
                      }
                      #endif //end    EstimateAlgorithm
 222   2              /*ä½¿èƒ½è¾“å‡º*/
 223   2              DRV_CMR |= 0x3F;                         // Uã€Vã€Wç›¸è¾“å‡º
 224   2              MOE = 1;
 225   2          }
 226   1      }
 227          
 228          /* -------------------------------------------------------------------------------------------------
 229              Function Name  : Motor_Open
 230              Description    : å¼€ç¯å¯åŠ¨çš„å‚æ•°é…ç½®
 231              Date           : 2020-04-10
 232              Parameter      : None
 233          ------------------------------------------------------------------------------------------------- */
 234          
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              12/02/2025 15:24:48 PAGE 5   

 235          extern uint16 xdata Hall_Angle_Arr[6];
 236          extern uint8  HallStatus;
 237          
 238          void Motor_Open(void)
 239          {
 240   1          static uint8 OpenRampCycles;
 241   1          float PwmDuty;
 242   1          float Angle;
 243   1          if (McStaSet.SetFlag.StartSetFlag == 0)
 244   1          {
 245   2              McStaSet.SetFlag.StartSetFlag = 1;
 246   2              FOC_Init();
 247   2              DRV_CMR |= 0x3F;                         // Uã€Vã€Wç›¸è¾“å‡º
 248   2              MOE = 1;
 249   2              if (GP42) 
 250   2              {
 251   3                  mcFocCtrl.LreanAngleFlt = (float)((int32)mcQEP.AngleFlt * 360.0) / 32767;
 252   3                  PwmDuty = mcPwmInput.PwmDuty / 32767.0;
 253   3                  Angle = (PwmDuty * 4098 - 1) / 4095 * 360.0 - mcFocCtrl.LreanAngleFlt;//(float)((int32)mcQEP.A
             -ngleFlt * 360.0) / 32767;
 254   3                  TIM2__CNTR = -P_Value(Angle) / Pole_Pairs;
 255   3                  FOC__THETA = _Q15(Angle /180.0);//ABS(mcFocCtrl.LreanAngleFlt) + ABS(mcFocCtrl.LreanAngleFlt);
 256   3              }
 257   2              else 
 258   2              {
 259   3                  TIM2__CNTR = 0;
 260   3                  FOC__THETA = 0;           
 261   3              }
 262   2              ClrBit(FOC_CR2, UDD);
 263   2              ClrBit(FOC_CR2, UQD);
 264   2           
 265   2              /*å¯åŠ¨ç”µæµã€KPã€KIã€FOC_EKPã€FOC_EKI*/
 266   2              FOC_IDREF = ID_Start_CURRENT;                         // Dè½´å¯åŠ¨ç”µæµ
 267   2              FOC_IQREF = IQ_Start_CURRENT;                          // Qè½´å¯åŠ¨ç”µæµ
 268   2              FOC_DQKP            = DQKP;
 269   2              FOC_DQKI            = DQKI;
 270   2              //    #elif (Open_Start_Mode == Open_Start)
 271   2              FOC_RTHEACC      = 0;      // çˆ¬å¡å‡½æ•°çš„åˆå§‹åŠ é€Ÿåº¦
 272   2              FOC__RTHESTEP    = 0;      // 0.62 degree acce speed
 273   2              FOC_RTHECNT      = 0;       // acce time
 274   2              ClrBit(FOC_CR1, EFAE);                                                          // ä¼°ç®—å™¨å¼ºåˆ¶
             -è¾“å‡º
 275   2              ClrBit(FOC_CR1, RFAE);                                                          // ç¦æ­¢å¼ºæ‹‰
 276   2              ClrBit(FOC_CR1, ANGM);
 277   2              OpenFlag = 1;
 278   2              mcState = mcRun;
 279   2          }
 280   1      }
 281          
 282          
 283          
 284          
 285          
 286          /* -------------------------------------------------------------------------------------------------
 287              Function Name  : Motor_Stop
 288              Description    : inital motor control parameter
 289              Date           : 2020-04-10
 290              Parameter      : None
 291          ------------------------------------------------------------------------------------------------- */
 292          void Motor_Stop(void)
 293          {
 294   1          if ((mcFocCtrl.SpeedFlt < Motor_Min_Speed) || (mcFocCtrl.State_Count == 0))
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              12/02/2025 15:24:48 PAGE 6   

 295   1          {
 296   2              #if (StopBrakeFlag == 0)
 297   2              {
 298   3                  mcState = mcReady;
 299   3                  FOC_CR1 = 0x00;
 300   3                  ClrBit(DRV_CR, FOCEN);   //å…³é—­FOC
 301   3                  
 302   3                  MOE = 0;
 303   3                  
 304   3              }
 305   2              #else
                      {
                          if (mcFocCtrl.SpeedFlt < Motor_Stop_Speed)
                          {
                              MOE = 0;
                              FOC_CR1 = 0x00;
                              ClrBit(DRV_CR, FOCEN);
                              DRV_DR   = DRV_ARR + 1;
                              DRV_CMR  = 0x00;
                              DRV_CMR |= 0x015;     // ä¸‰ç›¸ä¸‹æ¡¥è‡‚é€šï¼Œåˆ¹è½¦
                              ClrBit(DRV_CR, OCS);  // OCS = 0, DRV_COMR;OCS = 1, FOC/SVPWM/SPWM
                              SetBit(DRV_CR, DRVEN);
                              MOE = 1;
                              mcState  = mcBrake;
                              mcFocCtrl.State_Count = StopWaitTime;
                          }
                      }
                      #endif
 323   2          }
 324   1      }
 325          
 326          /* -------------------------------------------------------------------------------------------------
 327              Function Name  : MotorcontrolInit
 328              Description    : æ§åˆ¶å˜é‡åˆå§‹åŒ–æ¸…é›¶,åŒ…æ‹¬ä¿æŠ¤å‚æ•°çš„åˆå§‹åŒ–ã€ç”µæœºçŠ¶æ€åˆå§‹åŒ–
 329              Date           : 2020-04-10
 330              Parameter      : None
 331          ------------------------------------------------------------------------------------------------- */
 332          int32 debug_Cal;
 333          void MotorcontrolInit(void)
 334          {
 335   1          /*****ç”µæœºçŠ¶æ€æœºæ—¶åºå˜é‡***********/
 336   1          McStaSet.SetMode                   = 0;
 337   1          /**********ç”µæœºç›®æ ‡æ–¹å‘*************/
 338   1          mcCurOffset.IuOffsetSum            = 16383;
 339   1          mcCurOffset.IvOffsetSum            = 16383;
 340   1          mcCurOffset.Iw_busOffsetSum        = 16383;
 341   1          debug_Cal = QEPSpeedBase;
 342   1          mcQEP.SpeedCalBaseH = (QEPSpeedBase >> 16);
 343   1          mcQEP.SpeedCalBaseL = (QEPSpeedBase);
 344   1          Learn.FilishFlag = 0;
 345   1      //    mcQEP.ZSaveFlag = 1;
 346   1          Data[0] =  *(uint8 code *)(STARTPAGEROMADDRESS); 
 347   1          Data[1] += *(uint8 code *)(STARTPAGEROMADDRESS + 1);
 348   1          mcQEP.AngleFlt = ((int16)(Data[0] << 8) | (int16)Data[1]);
 349   1          Data[0] =  *(uint8 code *)(STARTPAGEROMADDRESS + 2); 
 350   1          Data[1] += *(uint8 code *)(STARTPAGEROMADDRESS + 3);
 351   1          Data[2] += *(uint8 code *)(STARTPAGEROMADDRESS + 4);
 352   1          Data[3] += *(uint8 code *)(STARTPAGEROMADDRESS + 5);
 353   1          mcQEP.ZeroNewCntr = ((int32)(Data[0] << 24) | (int32)(Data[1] << 16) | (int32)(Data[2] << 8) | (int32)
             -Data[3]);
 354   1      
 355   1      }
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              12/02/2025 15:24:48 PAGE 7   

 356          
 357          /* -------------------------------------------------------------------------------------------------
 358              Function Name  : VariablesPreInit
 359              Description    : åˆå§‹åŒ–ç”µæœºå‚æ•°
 360              Date           : 2020-04-10
 361              Parameter      : None
 362          ------------------------------------------------------------------------------------------------- */
 363          void VariablesPreInit(void)
 364          {
 365   1          mcFaultSource = 0;
 366   1          /* -----ä¿æŠ¤å‚æ•°åˆå§‹åŒ–----- */
 367   1          memset(&mcFaultDect, 0, sizeof(FaultVarible));                                                        
             -         // FaultVaribleå˜é‡æ¸…é›¶
 368   1          /* -----å¤–éƒ¨æ§åˆ¶ç¯å‚æ•°åˆå§‹åŒ–----- */
 369   1          memset(&mcFocCtrl, 0, sizeof(FOCCTRL));
 370   1          // mcFocCtrlå˜é‡æ¸…é›¶
 371   1          //    memset(&Uart, 0, sizeof(MCUART));
 372   1          memset(&Learn, 0, sizeof(SELFLEARN));
 373   1          
 374   1          
 375   1          /*****ç”µæœºçŠ¶æ€æœºæ—¶åºå˜é‡***********/
 376   1          McStaSet.SetMode                  = 0x01;   //ç”µæµæ ¡å‡†æ ‡å¿—ä½ç½®1ï¼Œå…¶å®ƒç½®0
 377   1          mcFocCtrl.State_Count = 0;
 378   1      
 379   1      }
 380          
 381          /* -------------------------------------------------------------------------------------------------
 382              Function Name  : GetCurrentOffset
 383              Description    : ä¸Šç”µæ—¶ï¼Œå…ˆå¯¹ç¡¬ä»¶ç”µè·¯çš„ç”µæµè¿›è¡Œé‡‡é›†ï¼Œå†™å…¥å¯¹åº”çš„æ ¡å‡†å¯„å­˜å™¨ä
             -¸­ã€‚
 384                               è°ƒè¯•æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffsetç»“æ„ä½“ä¸­å¯¹åº”å˜é‡æ˜¯å¦åœ¨èŒƒå›´å†…ã€‚é‡‡é›†ç»
             -“æŸåï¼ŒOffsetFlagç½®1ã€‚
 385              Date           : 2020-04-10
 386              Parameter      : None
 387          ------------------------------------------------------------------------------------------------- */
 388          void GetCurrentOffset(void)
 389          {
 390   1          if (!mcCurOffset.OffsetFlag)
 391   1          {
 392   2              SetBit(ADC_CR, ADCBSY);             // ä½¿èƒ½ADC
 393   2              
 394   2              while (ReadBit(ADC_CR, ADCBSY));
 395   2              
 396   2              #if (Shunt_Resistor_Mode == Single_Resistor)                   //å•ç”µé˜»æ¨¡å¼
                      {
                          mcCurOffset.Iw_busOffsetSum += ((ADC4_DR & 0x7ff8));
                          mcCurOffset.Iw_busOffset     = mcCurOffset.Iw_busOffsetSum >> 4;
                          mcCurOffset.Iw_busOffsetSum -= mcCurOffset.Iw_busOffset;
                      }
                      #elif (Shunt_Resistor_Mode == Double_Resistor)                 //åŒç”µé˜»æ¨¡å¼
 403   2              {
 404   3                  mcCurOffset.IuOffsetSum     += ((ADC0_DR & 0x7ff8));
 405   3                  mcCurOffset.IuOffset         = mcCurOffset.IuOffsetSum >> 4;
 406   3                  mcCurOffset.IuOffsetSum     -= mcCurOffset.IuOffset;
 407   3                  mcCurOffset.IvOffsetSum     += ((ADC1_DR & 0x7ff8));
 408   3                  mcCurOffset.IvOffset         = mcCurOffset.IvOffsetSum >> 4;
 409   3                  mcCurOffset.IvOffsetSum     -= mcCurOffset.IvOffset;
 410   3              }
 411   2              #elif (Shunt_Resistor_Mode == Three_Resistor)                 //ä¸‰ç”µé˜»æ¨¡å¼
                      {
                          mcCurOffset.IuOffsetSum     += ((ADC0_DR & 0x7ff8));
                          mcCurOffset.IuOffset         = mcCurOffset.IuOffsetSum >> 4;
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              12/02/2025 15:24:48 PAGE 8   

                          mcCurOffset.IuOffsetSum     -= mcCurOffset.IuOffset;
                          mcCurOffset.IvOffsetSum     += ((ADC1_DR & 0x7ff8));
                          mcCurOffset.IvOffset         = mcCurOffset.IvOffsetSum >> 4;
                          mcCurOffset.IvOffsetSum     -= mcCurOffset.IvOffset;
                          mcCurOffset.Iw_busOffsetSum += ((ADC4_DR & 0x7ff8));
                          mcCurOffset.Iw_busOffset     = mcCurOffset.Iw_busOffsetSum >> 4;
                          mcCurOffset.Iw_busOffsetSum -= mcCurOffset.Iw_busOffset;
                      }
                      #endif
 424   2              mcCurOffset.OffsetCount++;
 425   2              
 426   2              if (mcCurOffset.OffsetCount > Calib_Time)
 427   2              {
 428   3                  mcCurOffset.OffsetFlag = 1;
 429   3              }
 430   2          }
 431   1      }
 432          
 433          /* -------------------------------------------------------------------------------------------------
 434              Function Name  : Motor_Ready
 435              Description    : ä¸Šç”µæ—¶ï¼Œå…³é—­è¾“å‡ºï¼Œå…ˆå¯¹ç¡¬ä»¶ç”µè·¯çš„ç”µæµè¿›è¡Œé‡‡é›†ï¼Œåœ¨FOC_Initä¸­å†
             -™å…¥å¯¹åº”çš„æ ¡å‡†å¯„å­˜å™¨ä¸­ã€‚
 436                               è°ƒè¯•æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffsetç»“æ„ä½“ä¸­å¯¹åº”å˜é‡æ˜¯å¦åœ¨èŒƒå›´å†…ã€‚
 437              Date           : 2020-04-10
 438              Parameter      : None
 439          ------------------------------------------------------------------------------------------------- */
 440          void Motor_Ready(void)
 441          {
 442   1          if (McStaSet.SetFlag.CalibFlag == 0)
 443   1          {
 444   2              McStaSet.SetFlag.CalibFlag = 1;
 445   2              ClrBit(DRV_CR, FOCEN);
 446   2              MOE = 0;
 447   2              SetBit(ADC_MASK, CH4EN | CH2EN | CH1EN | CH0EN);
 448   2              mcCurOffset.OffsetFlag = 0;
 449   2              mcCurOffset.OffsetCount = 0;    //åç½®ç”µå‹é‡‡é›†è®¡æ•°
 450   2          }
 451   1      }
 452          
 453          /* -------------------------------------------------------------------------------------------------
 454              Function Name  : Motor_Init
 455              Description    : å¯¹ç”µæœºç›¸å…³å˜é‡ã€PIè¿›è¡Œåˆå§‹åŒ–è®¾ç½®
 456              Date           : 2020-04-10
 457              Parameter      : None
 458          ------------------------------------------------------------------------------------------------- */
 459          void Motor_Init(void)
 460          {
 461   1          ClrBit(ADC_MASK, CH4EN | CH1EN | CH0EN);      // å…³é—­è½¯ä»¶ç”µæµé‡‡æ ·çš„ADC
 462   1          VariablesPreInit();                           // ç”µæœºç›¸å…³å˜é‡åˆå§‹åŒ–
 463   1          SetBit(DRV_CR, DRVEN);
 464   1      }
 465          
 466          
 467          
 468          
 469          
 470          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1541    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              12/02/2025 15:24:48 PAGE 9   

   XDATA SIZE       =     31       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
